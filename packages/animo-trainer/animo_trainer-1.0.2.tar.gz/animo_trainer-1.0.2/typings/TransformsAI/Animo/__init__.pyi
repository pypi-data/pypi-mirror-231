import typing, clr, abc
from TransformsAI.Animo.Numerics import Vec2Int, Vec3Int
from System import Guid, ValueTuple_2, Func_2, IEquatable_1, MulticastDelegate, IAsyncResult, AsyncCallback, Array_1, Random, Predicate_1
from System.Collections.Generic import List_1, HashSet_1, Dictionary_2
from TransformsAI.Animo.Intents import Intent, UseIntent
from TransformsAI.Animo.Constants import TypeIds, Effects, GroundMaterials
from TransformsAI.Animo.Objects.Character import CharacterObject
from System.Reflection import MethodInfo
from TransformsAI.Animo.Tools import ReadOnlyList_1, PooledList_1
from TransformsAI.Animo.Config import AnimoConfig

class Actor(GridObject):
    Info : ObjectInfo
    LastTurnHeldObject : HoldableObject
    @property
    def BurnAmount(self) -> int: ...
    @property
    def Cell(self) -> Vec2Int: ...
    @property
    def Container(self) -> GridObject: ...
    @Container.setter
    def Container(self, value: GridObject) -> GridObject: ...
    @property
    def DidDropFail(self) -> bool: ...
    @property
    def DidGrabFail(self) -> bool: ...
    @property
    def Direction(self) -> Directions: ...
    @property
    def Grid(self) -> VoxelGrid: ...
    @property
    def Height(self) -> int: ...
    @property
    def HeldObject(self) -> HoldableObject: ...
    @property
    def InstanceId(self) -> Guid: ...
    @property
    def IntentsFiredThisTurn(self) -> List_1[Intent]: ...
    @property
    def IsOnGrid(self) -> bool: ...
    @property
    def IsStoodUpon(self) -> bool: ...
    @property
    def MainIntent(self) -> Intent: ...
    @property
    def OriginalInstanceId(self) -> Guid: ...
    @property
    def Position(self) -> Vec3Int: ...
    @property
    def StateObservation(self) -> ValueTuple_2[float, float]: ...
    @property
    def Transform(self) -> GridTransform: ...
    @Transform.setter
    def Transform(self, value: GridTransform) -> GridTransform: ...
    @property
    def TransformedInto(self) -> GridObject: ...
    @property
    def TransformOnGrid(self) -> None: ...
    @TransformOnGrid.setter
    def TransformOnGrid(self, value: typing.Optional[GridTransform]) -> None: ...
    @property
    def TypeId(self) -> TypeIds: ...
    @property
    def UsedIntent(self) -> UseIntent: ...
    @property
    def VariantId(self) -> int: ...
    @VariantId.setter
    def VariantId(self, value: int) -> int: ...
    @property
    def WasDestroyedOrTransformed(self) -> bool: ...
    def CanGrab(self, holdableObject: HoldableObject, ignoreAlreadyHeld: bool = ...) -> bool: ...
    def CanRelease(self, holdableObject: HoldableObject) -> bool: ...
    @abc.abstractmethod
    def CanWalkForward(self) -> bool: ...
    def GetSubObjects(self, outObjects: List_1[SubObjectField]) -> None: ...
    def GetTapOverrideIntent(self, actor: Actor) -> Intent: ...
    def Grab(self, holdableObject: HoldableObject, outIntents: List_1[Intent]) -> None: ...
    def OnDestroyed(self, originGrid: VoxelGrid, outIntents: List_1[Intent]) -> None: ...
    def Release(self, objectToRelease: HoldableObject, outIntents: List_1[Intent]) -> None: ...


class Directions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Forward : Directions # 0
    Back : Directions # 1
    Right : Directions # 2
    Left : Directions # 3


class DirectionsExtensions(abc.ABC):
    @staticmethod
    def GetAbsoluteDirection(direction: Directions, relativeDirection: Directions) -> Directions: ...
    @staticmethod
    def GetAbsoluteVector(direction: Directions, relativeDirection: Vec2Int) -> Vec2Int: ...
    @staticmethod
    def GetRelativeDirection(direction: Directions, absoluteDirection: Directions) -> Directions: ...
    @staticmethod
    def GetRelativeVector(direction: Directions, absoluteDirection: Vec2Int) -> Vec2Int: ...


class GridObject(abc.ABC):
    Info : ObjectInfo
    StateObservationLength : int
    @property
    def BurnAmount(self) -> int: ...
    @BurnAmount.setter
    def BurnAmount(self, value: int) -> int: ...
    @property
    def Cell(self) -> Vec2Int: ...
    @property
    def Container(self) -> GridObject: ...
    @Container.setter
    def Container(self, value: GridObject) -> GridObject: ...
    @property
    def Direction(self) -> Directions: ...
    @property
    def Grid(self) -> VoxelGrid: ...
    @property
    def Height(self) -> int: ...
    @property
    def InstanceId(self) -> Guid: ...
    @InstanceId.setter
    def InstanceId(self, value: Guid) -> Guid: ...
    @property
    def IntentsFiredThisTurn(self) -> List_1[Intent]: ...
    @property
    def IsOnGrid(self) -> bool: ...
    @property
    def IsStoodUpon(self) -> bool: ...
    @property
    def MainIntent(self) -> Intent: ...
    @MainIntent.setter
    def MainIntent(self, value: Intent) -> Intent: ...
    @property
    def OriginalInstanceId(self) -> Guid: ...
    @property
    def Position(self) -> Vec3Int: ...
    @property
    def StateObservation(self) -> ValueTuple_2[float, float]: ...
    @property
    def Transform(self) -> GridTransform: ...
    @Transform.setter
    def Transform(self, value: GridTransform) -> GridTransform: ...
    @property
    def TransformedInto(self) -> GridObject: ...
    @property
    def TransformOnGrid(self) -> None: ...
    @TransformOnGrid.setter
    def TransformOnGrid(self, value: typing.Optional[GridTransform]) -> None: ...
    @property
    def TypeId(self) -> TypeIds: ...
    @property
    def UsedIntent(self) -> UseIntent: ...
    @property
    def VariantId(self) -> int: ...
    @VariantId.setter
    def VariantId(self, value: int) -> int: ...
    @property
    def WasDestroyedOrTransformed(self) -> bool: ...
    def CanBePushedTo(self, floorAtPushTarget: Vec3Int) -> bool: ...
    def CanBeUsedOnGridBy(self, character: CharacterObject) -> bool: ...
    def CanChangeFloorHeight(self, cellPosition: Vec2Int, newFloorHeight: typing.Optional[int], newPosition: clr.Reference[Vec3Int]) -> bool: ...
    def ContinueUsingActionOverride(self, decidedAction: CharacterObject.Actions) -> CharacterObject.Actions: ...
    def ContinueUsingIntentOverride(self, characterAction: CharacterObject.Actions, intent: clr.Reference[UseIntent]) -> bool: ...
    def Destroy(self, outIntents: List_1[Intent], originGrid: VoxelGrid = ...) -> None: ...
    def DestroyAtPosition(self, position: Vec3Int, grid: VoxelGrid, outIntents: List_1[Intent]) -> None: ...
    def GetCausedIntents(self, outIntents: List_1[Intent]) -> None: ...
    def GetIssuedIntents(self, outIntents: List_1[Intent]) -> None: ...
    def GetSubObjects(self, outObjects: List_1[SubObjectField]) -> None: ...
    def GetSubObjectsRecursive(self, outObjects: List_1[GridObject]) -> None: ...
    def OnAfterStep(self) -> None: ...
    def OnDestroyed(self, originGrid: VoxelGrid, outIntents: List_1[Intent]) -> None: ...
    def OnEffect(self, effect: Effects, source: GridObject, outIntents: List_1[Intent]) -> bool: ...
    def OnOverlapEnded(self, outIntents: List_1[Intent], overlappingObject: GridObject) -> None: ...
    def OnOverlapStarted(self, outIntents: List_1[Intent], overlappingObject: GridObject) -> None: ...
    def OverrideMainIntent(self, intent: Intent) -> None: ...
    def PrepareForStep(self) -> None: ...
    def RemoveFromGrid(self, outIntents: List_1[Intent]) -> None: ...
    def TransformInto(self, typeIds: TypeIds, outIntents: List_1[Intent]) -> GridObject: ...
    def TryRotate(self, targetDirection: Vec2Int, outIntents: List_1[Intent]) -> bool: ...
    def UsedOnGrid(self, user: CharacterObject, intent: clr.Reference[UseIntent]) -> bool: ...
    # Skipped FindCausedIntent due to it being static, abstract and generic.

    FindCausedIntent : FindCausedIntent_MethodGroup
    class FindCausedIntent_MethodGroup:
        def __getitem__(self, t:typing.Type[FindCausedIntent_1_T1]) -> FindCausedIntent_1[FindCausedIntent_1_T1]: ...

        FindCausedIntent_1_T1 = typing.TypeVar('FindCausedIntent_1_T1')
        class FindCausedIntent_1(typing.Generic[FindCausedIntent_1_T1]):
            FindCausedIntent_1_T = GridObject.FindCausedIntent_MethodGroup.FindCausedIntent_1_T1
            def __call__(self, grid: VoxelGrid, includeCancelled: bool, selector: Func_2[FindCausedIntent_1_T, bool] = ...) -> FindCausedIntent_1_T:...


    # Skipped FindCausedIntents due to it being static, abstract and generic.

    FindCausedIntents : FindCausedIntents_MethodGroup
    class FindCausedIntents_MethodGroup:
        def __getitem__(self, t:typing.Type[FindCausedIntents_1_T1]) -> FindCausedIntents_1[FindCausedIntents_1_T1]: ...

        FindCausedIntents_1_T1 = typing.TypeVar('FindCausedIntents_1_T1')
        class FindCausedIntents_1(typing.Generic[FindCausedIntents_1_T1]):
            FindCausedIntents_1_T = GridObject.FindCausedIntents_MethodGroup.FindCausedIntents_1_T1
            def __call__(self, grid: VoxelGrid, includeCancelled: bool, outIntents: List_1[FindCausedIntents_1_T], selector: Func_2[FindCausedIntents_1_T, bool] = ...) -> int:...


    # Skipped FindIssuedIntent due to it being static, abstract and generic.

    FindIssuedIntent : FindIssuedIntent_MethodGroup
    class FindIssuedIntent_MethodGroup:
        def __getitem__(self, t:typing.Type[FindIssuedIntent_1_T1]) -> FindIssuedIntent_1[FindIssuedIntent_1_T1]: ...

        FindIssuedIntent_1_T1 = typing.TypeVar('FindIssuedIntent_1_T1')
        class FindIssuedIntent_1(typing.Generic[FindIssuedIntent_1_T1]):
            FindIssuedIntent_1_T = GridObject.FindIssuedIntent_MethodGroup.FindIssuedIntent_1_T1
            def __call__(self, includeCancelled: bool, selector: Func_2[FindIssuedIntent_1_T, bool] = ...) -> FindIssuedIntent_1_T:...


    # Skipped LeaseIntent due to it being static, abstract and generic.

    LeaseIntent : LeaseIntent_MethodGroup
    class LeaseIntent_MethodGroup:
        def __getitem__(self, t:typing.Type[LeaseIntent_1_T1]) -> LeaseIntent_1[LeaseIntent_1_T1]: ...

        LeaseIntent_1_T1 = typing.TypeVar('LeaseIntent_1_T1')
        class LeaseIntent_1(typing.Generic[LeaseIntent_1_T1]):
            LeaseIntent_1_T = GridObject.LeaseIntent_MethodGroup.LeaseIntent_1_T1
            @typing.overload
            def __call__(self) -> LeaseIntent_1_T:...
            @typing.overload
            def __call__(self, user: Actor) -> LeaseIntent_1_T:...
            @typing.overload
            def __call__(self, grid: VoxelGrid) -> LeaseIntent_1_T:...


    # Skipped TryAddToGrid due to it being static, abstract and generic.

    TryAddToGrid : TryAddToGrid_MethodGroup
    class TryAddToGrid_MethodGroup:
        @typing.overload
        def __call__(self, grid: VoxelGrid, cell: Vec2Int, wasCreated: bool, outIntents: List_1[Intent]) -> bool:...
        @typing.overload
        def __call__(self, grid: VoxelGrid, transform: GridTransform, wasCreated: bool, outIntents: List_1[Intent]) -> bool:...

    # Skipped TryMove due to it being static, abstract and generic.

    TryMove : TryMove_MethodGroup
    class TryMove_MethodGroup:
        @typing.overload
        def __call__(self, cellPosition: Vec2Int, outIntents: List_1[Intent]) -> bool:...
        @typing.overload
        def __call__(self, target: GridTransform, outIntents: List_1[Intent], originGroundMaterial: typing.Optional[GroundMaterials] = ...) -> bool:...



class GridObjectExtensions(abc.ABC):
    @staticmethod
    def DestroyImmediate(obj: GridObject) -> None: ...
    @staticmethod
    def RotateImmediate(obj: GridObject, targetDirection: Vec2Int) -> bool: ...
    @staticmethod
    def TryRotateImmediate(obj: GridObject, direction: Vec2Int) -> bool: ...
    @staticmethod
    def UnstunImmediate(obj: CharacterObject) -> None: ...
    # Skipped TryAddToGridImmediate due to it being static, abstract and generic.

    TryAddToGridImmediate : TryAddToGridImmediate_MethodGroup
    class TryAddToGridImmediate_MethodGroup:
        @typing.overload
        def __call__(self, obj: GridObject, grid: VoxelGrid, cell: Vec2Int, wasCreated: bool) -> bool:...
        @typing.overload
        def __call__(self, obj: GridObject, grid: VoxelGrid, transform: GridTransform, wasCreated: bool) -> bool:...

    # Skipped TryMoveImmediate due to it being static, abstract and generic.

    TryMoveImmediate : TryMoveImmediate_MethodGroup
    class TryMoveImmediate_MethodGroup:
        @typing.overload
        def __call__(self, obj: GridObject, cellPosition: Vec2Int) -> bool:...
        @typing.overload
        def __call__(self, obj: GridObject, transform: GridTransform) -> bool:...



class GridTransform(IEquatable_1[GridTransform]):
    @typing.overload
    def __init__(self, position: Vec3Int) -> None: ...
    @typing.overload
    def __init__(self, position: Vec3Int, direction: Vec2Int) -> None: ...
    @typing.overload
    def __init__(self, position: Vec3Int, direction: Directions) -> None: ...
    @property
    def Back(self) -> Vec2Int: ...
    @property
    def BackCell(self) -> Vec2Int: ...
    @property
    def Cell(self) -> Vec2Int: ...
    @property
    def Direction(self) -> Directions: ...
    @property
    def Forward(self) -> Vec2Int: ...
    @property
    def FrontCell(self) -> Vec2Int: ...
    @property
    def Left(self) -> Vec2Int: ...
    @property
    def LeftCell(self) -> Vec2Int: ...
    @property
    def Position(self) -> Vec3Int: ...
    @property
    def Right(self) -> Vec2Int: ...
    @property
    def RightCell(self) -> Vec2Int: ...
    def GetAbsoluteDirection(self, relativeDirection: Vec2Int) -> Vec2Int: ...
    def GetAbsolutePosition(self, relativePosition: Vec3Int) -> Vec3Int: ...
    def GetCellAt(self, direction: Directions) -> Vec2Int: ...
    def GetDirectionVector(self, direction: Directions) -> Vec2Int: ...
    def GetHashCode(self) -> int: ...
    def GetRelativeDirection(self, absoluteDirection: Vec2Int) -> Vec2Int: ...
    def GetRelativePosition(self, absolutePosition: Vec3Int) -> Vec3Int: ...
    def __eq__(self, left: GridTransform, right: GridTransform) -> bool: ...
    def __ne__(self, left: GridTransform, right: GridTransform) -> bool: ...
    def ToString(self) -> str: ...
    def WithDirection(self, direction: Vec2Int) -> GridTransform: ...
    def WithPosition(self, position: Vec3Int) -> GridTransform: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: GridTransform) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class HoldableObject(GridObject):
    Info : ObjectInfo
    @property
    def BurnAmount(self) -> int: ...
    @property
    def Cell(self) -> Vec2Int: ...
    @property
    def Container(self) -> GridObject: ...
    @Container.setter
    def Container(self, value: GridObject) -> GridObject: ...
    @property
    def Direction(self) -> Directions: ...
    @property
    def GrabPriority(self) -> float: ...
    @property
    def Grid(self) -> VoxelGrid: ...
    @property
    def Height(self) -> int: ...
    @property
    def Holder(self) -> Actor: ...
    @property
    def InstanceId(self) -> Guid: ...
    @property
    def IntentsFiredThisTurn(self) -> List_1[Intent]: ...
    @property
    def IsBeingHeld(self) -> bool: ...
    @property
    def IsOnGrid(self) -> bool: ...
    @property
    def IsStoodUpon(self) -> bool: ...
    @property
    def MainIntent(self) -> Intent: ...
    @property
    def OriginalInstanceId(self) -> Guid: ...
    @property
    def Position(self) -> Vec3Int: ...
    @property
    def StateObservation(self) -> ValueTuple_2[float, float]: ...
    @property
    def Transform(self) -> GridTransform: ...
    @Transform.setter
    def Transform(self, value: GridTransform) -> GridTransform: ...
    @property
    def TransformedInto(self) -> GridObject: ...
    @property
    def TransformOnGrid(self) -> None: ...
    @TransformOnGrid.setter
    def TransformOnGrid(self, value: typing.Optional[GridTransform]) -> None: ...
    @property
    def TypeId(self) -> TypeIds: ...
    @property
    def UsedIntent(self) -> UseIntent: ...
    @property
    def VariantId(self) -> int: ...
    @VariantId.setter
    def VariantId(self, value: int) -> int: ...
    @property
    def WasDestroyedOrTransformed(self) -> bool: ...
    def CanBeGrabbed(self, source: Actor) -> bool: ...
    def CanBeReleased(self) -> bool: ...
    def Destroy(self, outIntents: List_1[Intent], originGrid: VoxelGrid = ...) -> None: ...
    @abc.abstractmethod
    def GetUseIntentHeld(self, user: Actor) -> UseIntent: ...
    def OnDestroyed(self, originGrid: VoxelGrid, outIntents: List_1[Intent]) -> None: ...
    def TransformInto(self, typeIds: TypeIds, outIntents: List_1[Intent]) -> GridObject: ...


class IntentConflictResolver(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, originalIntents: List_1[Intent], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, originalIntents: List_1[Intent]) -> None: ...


class ISimulationObserver(typing.Protocol):
    @abc.abstractmethod
    def OnIntentExecuted(self, intent: Intent) -> None: ...
    @abc.abstractmethod
    def OnStepCompleted(self, grid: VoxelGrid) -> None: ...


class MoveResults(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Fail : MoveResults # 0
    Walk : MoveResults # 1
    JumpUp : MoveResults # 2
    JumpDown : MoveResults # 3


class ObjectGroup(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Regular : ObjectGroup # 0
    Mediums : ObjectGroup # 1
    Actors : ObjectGroup # 2


class ObjectInfo(IEquatable_1[ObjectInfo], abc.ABC):
    @property
    def CanStepOnObjects(self) -> bool: ...
    @property
    def CreatesObjects(self) -> Array_1[TypeIds]: ...
    @property
    def IsDestroyedInDeepWater(self) -> bool: ...
    @property
    def IsDestroyedInShallowWater(self) -> bool: ...
    @property
    def IsDestructible(self) -> bool: ...
    @property
    def IsGrabbable(self) -> bool: ...
    @property
    def IsOccupier(self) -> bool: ...
    @property
    def IsUsableOnGrid(self) -> bool: ...
    @property
    def LabelName(self) -> str: ...
    @property
    def MaximumBurnAmount(self) -> int: ...
    @property
    def ObjectGroup(self) -> ObjectGroup: ...
    @property
    def TransformsInto(self) -> Array_1[TypeIds]: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    @property
    def TypeId(self) -> TypeIds: ...
    @property
    def UsePriority(self) -> float: ...
    def CanOverlap(self, b: TypeIds) -> bool: ...
    @abc.abstractmethod
    def CanReceiveEffect(self, effect: Effects) -> bool: ...
    @abc.abstractmethod
    def CreateObject(self) -> GridObject: ...
    def DoesCreate(self, typeIds: TypeIds) -> bool: ...
    def DoesTransformInto(self, typeIds: TypeIds) -> bool: ...
    def GetAccessSet(self, set: HashSet_1[TypeIds]) -> None: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: ObjectInfo, right: ObjectInfo) -> bool: ...
    def __ne__(self, left: ObjectInfo, right: ObjectInfo) -> bool: ...
    def RegisterConflictResolvers(self) -> List_1[ValueTuple_2[float, IntentConflictResolver]]: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: ObjectInfo) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class Resolution(GridObject):
    Info : ObjectInfo
    @property
    def BasePriority(self) -> int: ...
    @property
    def BurnAmount(self) -> int: ...
    @property
    def Cell(self) -> Vec2Int: ...
    @property
    def Container(self) -> GridObject: ...
    @Container.setter
    def Container(self, value: GridObject) -> GridObject: ...
    @property
    def Creator(self) -> GridObject: ...
    @Creator.setter
    def Creator(self, value: GridObject) -> GridObject: ...
    @property
    def Direction(self) -> Directions: ...
    @property
    def Grid(self) -> VoxelGrid: ...
    @property
    def Height(self) -> int: ...
    @property
    def InstanceId(self) -> Guid: ...
    @property
    def IntentsFiredThisTurn(self) -> List_1[Intent]: ...
    @property
    def IsOnGrid(self) -> bool: ...
    @property
    def IsStoodUpon(self) -> bool: ...
    @property
    def MainIntent(self) -> Intent: ...
    @property
    def OriginalInstanceId(self) -> Guid: ...
    @property
    def Position(self) -> Vec3Int: ...
    @property
    def StateObservation(self) -> ValueTuple_2[float, float]: ...
    @property
    def Transform(self) -> GridTransform: ...
    @Transform.setter
    def Transform(self, value: GridTransform) -> GridTransform: ...
    @property
    def TransformedInto(self) -> GridObject: ...
    @property
    def TransformOnGrid(self) -> None: ...
    @TransformOnGrid.setter
    def TransformOnGrid(self, value: typing.Optional[GridTransform]) -> None: ...
    @property
    def TypeId(self) -> TypeIds: ...
    @property
    def UsedIntent(self) -> UseIntent: ...
    @property
    def VariantId(self) -> int: ...
    @VariantId.setter
    def VariantId(self, value: int) -> int: ...
    @property
    def WasDestroyedOrTransformed(self) -> bool: ...


class SimulationRunner:
    def __init__(self, grid: VoxelGrid) -> None: ...
    observers : List_1[ISimulationObserver]
    @property
    def HasStrayIntents(self) -> bool: ...
    @property
    def Intents(self) -> ReadOnlyList_1[Intent]: ...
    @property
    def StrayIntents(self) -> List_1[Intent]: ...
    def ExecuteIntents(self, intentQueue: List_1[Intent]) -> None: ...
    def FlushStrayIntents(self) -> None: ...
    def GetIntentsCausedBy(self, gridObject: GridObject, outIntents: List_1[Intent]) -> None: ...
    def GetIntentsIssuedBy(self, gridObject: GridObject, outIntents: List_1[Intent]) -> None: ...
    def Simulate(self) -> None: ...
    # Skipped FindIntent due to it being static, abstract and generic.

    FindIntent : FindIntent_MethodGroup
    class FindIntent_MethodGroup:
        def __getitem__(self, t:typing.Type[FindIntent_1_T1]) -> FindIntent_1[FindIntent_1_T1]: ...

        FindIntent_1_T1 = typing.TypeVar('FindIntent_1_T1')
        class FindIntent_1(typing.Generic[FindIntent_1_T1]):
            FindIntent_1_T = SimulationRunner.FindIntent_MethodGroup.FindIntent_1_T1
            def __call__(self, selector: Func_2[FindIntent_1_T, bool] = ...) -> FindIntent_1_T:...


    # Skipped FindIntents due to it being static, abstract and generic.

    FindIntents : FindIntents_MethodGroup
    class FindIntents_MethodGroup:
        def __getitem__(self, t:typing.Type[FindIntents_1_T1]) -> FindIntents_1[FindIntents_1_T1]: ...

        FindIntents_1_T1 = typing.TypeVar('FindIntents_1_T1')
        class FindIntents_1(typing.Generic[FindIntents_1_T1]):
            FindIntents_1_T = SimulationRunner.FindIntents_MethodGroup.FindIntents_1_T1
            def __call__(self, outIntents: List_1[FindIntents_1_T], selector: Func_2[FindIntents_1_T, bool] = ...) -> int:...




class SubObjectField_GenericClasses(abc.ABCMeta):
    Generic_SubObjectField_GenericClasses_SubObjectField_1_T = typing.TypeVar('Generic_SubObjectField_GenericClasses_SubObjectField_1_T')
    def __getitem__(self, types : typing.Type[Generic_SubObjectField_GenericClasses_SubObjectField_1_T]) -> typing.Type[SubObjectField_1[Generic_SubObjectField_GenericClasses_SubObjectField_1_T]]: ...

class SubObjectField(SubObjectField_0, metaclass =SubObjectField_GenericClasses): ...

class SubObjectField_0:
    def __init__(self, container: GridObject) -> None: ...
    @property
    def Container(self) -> GridObject: ...
    @Container.setter
    def Container(self, value: GridObject) -> GridObject: ...
    @property
    def Value(self) -> GridObject: ...
    @Value.setter
    def Value(self, value: GridObject) -> GridObject: ...


SubObjectField_1_T = typing.TypeVar('SubObjectField_1_T')
class SubObjectField_1(typing.Generic[SubObjectField_1_T], SubObjectField_0):
    def __init__(self, container: GridObject) -> None: ...
    @property
    def Container(self) -> GridObject: ...
    @property
    def Value(self) -> SubObjectField_1_T: ...
    @Value.setter
    def Value(self, value: SubObjectField_1_T) -> SubObjectField_1_T: ...
    @property
    def Value(self) -> GridObject: ...
    @Value.setter
    def Value(self, value: GridObject) -> GridObject: ...


class VoxelGrid:
    @property
    def CentreCell(self) -> Vec2Int: ...
    @property
    def Characters(self) -> Dictionary_2.ValueCollection_2[int, CharacterObject]: ...
    @property
    def Config(self) -> AnimoConfig: ...
    @property
    def Objects(self) -> Dictionary_2.ValueCollection_2[Guid, GridObject]: ...
    @property
    def ObjectsOnGrid(self) -> HashSet_1[GridObject]: ...
    @property
    def Random(self) -> Random: ...
    @property
    def SimulationRunner(self) -> SimulationRunner: ...
    @property
    def Size(self) -> Vec2Int: ...
    def Copy(self) -> VoxelGrid: ...
    @staticmethod
    def CreateCircle(size: Vec2Int, platformRadius: int, platformHeight: int) -> VoxelGrid: ...
    @staticmethod
    def CreateFlat(size: Vec2Int, floorLine: typing.Optional[int] = ..., waterLine: int = ...) -> VoxelGrid: ...
    def FindClosestGroundMaterial(self, cell: Vec2Int, material: GroundMaterials) -> typing.Optional[Vec3Int]: ...
    @staticmethod
    def FromJson(json: str) -> VoxelGrid: ...
    def GetCharacter(self, characterId: typing.Optional[int]) -> CharacterObject: ...
    def GetFloorHeight(self, cellPosition: Vec2Int) -> typing.Optional[int]: ...
    def GetGroundMaterialAt(self, cellPosition: Vec2Int) -> GroundMaterials: ...
    def GetObjectsAt(self, cellPosition: Vec2Int) -> ReadOnlyList_1[GridObject]: ...
    def GetSurfaceHeight(self, cellPosition: Vec2Int) -> int: ...
    def GetSurfacePosition(self, cellPosition: Vec2Int) -> Vec3Int: ...
    def HasFloorAt(self, cellPosition: Vec2Int) -> bool: ...
    def HasWaterAt(self, position: Vec3Int) -> bool: ...
    def IsSurfacePosition(self, currentPoint: Vec3Int) -> bool: ...
    def Resize(self, newSize: Vec2Int) -> None: ...
    def TryAddBlockAt(self, cellPosition: Vec2Int, outIntents: List_1[Intent]) -> bool: ...
    def TryRemoveBlockAt(self, cellPosition: Vec2Int, outIntents: List_1[Intent]) -> bool: ...
    def TrySetFloorHeightAt(self, cellPosition: Vec2Int, newFloorHeight: typing.Optional[int], outIntents: List_1[Intent]) -> bool: ...
    # Skipped CanPlace due to it being static, abstract and generic.

    CanPlace : CanPlace_MethodGroup
    class CanPlace_MethodGroup:
        @typing.overload
        def __call__(self, existingObject: GridObject, cellPosition: Vec2Int) -> bool:...
        @typing.overload
        def __call__(self, objectType: TypeIds, cellPosition: Vec2Int, objToIgnore: GridObject = ...) -> bool:...

    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, objId: Guid) -> bool:...
        @typing.overload
        def __call__(self, obj: GridObject) -> bool:...

    # Skipped CountObjects due to it being static, abstract and generic.

    CountObjects : CountObjects_MethodGroup
    class CountObjects_MethodGroup:
        def __getitem__(self, t:typing.Type[CountObjects_1_T1]) -> CountObjects_1[CountObjects_1_T1]: ...

        CountObjects_1_T1 = typing.TypeVar('CountObjects_1_T1')
        class CountObjects_1(typing.Generic[CountObjects_1_T1]):
            CountObjects_1_T = VoxelGrid.CountObjects_MethodGroup.CountObjects_1_T1
            def __call__(self, filter: Predicate_1[CountObjects_1_T] = ...) -> int:...


    # Skipped FindClosestAt due to it being static, abstract and generic.

    FindClosestAt : FindClosestAt_MethodGroup
    class FindClosestAt_MethodGroup:
        def __getitem__(self, t:typing.Type[FindClosestAt_1_T1]) -> FindClosestAt_1[FindClosestAt_1_T1]: ...

        FindClosestAt_1_T1 = typing.TypeVar('FindClosestAt_1_T1')
        class FindClosestAt_1(typing.Generic[FindClosestAt_1_T1]):
            FindClosestAt_1_T = VoxelGrid.FindClosestAt_MethodGroup.FindClosestAt_1_T1
            def __call__(self, cell: Vec2Int, maxDistance: float, predicate: Predicate_1[FindClosestAt_1_T] = ...) -> FindClosestAt_1_T:...

        def __call__(self, cell: Vec2Int, typeId: TypeIds, maxDistance: float, ignored: GridObject = ...) -> GridObject:...

    # Skipped FindObject due to it being static, abstract and generic.

    FindObject : FindObject_MethodGroup
    class FindObject_MethodGroup:
        def __getitem__(self, t:typing.Type[FindObject_1_T1]) -> FindObject_1[FindObject_1_T1]: ...

        FindObject_1_T1 = typing.TypeVar('FindObject_1_T1')
        class FindObject_1(typing.Generic[FindObject_1_T1]):
            FindObject_1_T = VoxelGrid.FindObject_MethodGroup.FindObject_1_T1
            def __call__(self, filter: Predicate_1[FindObject_1_T] = ...) -> FindObject_1_T:...

        def __call__(self, filter: Predicate_1[GridObject] = ...) -> GridObject:...

    # Skipped GetObjectAt due to it being static, abstract and generic.

    GetObjectAt : GetObjectAt_MethodGroup
    class GetObjectAt_MethodGroup:
        def __getitem__(self, t:typing.Type[GetObjectAt_1_T1]) -> GetObjectAt_1[GetObjectAt_1_T1]: ...

        GetObjectAt_1_T1 = typing.TypeVar('GetObjectAt_1_T1')
        class GetObjectAt_1(typing.Generic[GetObjectAt_1_T1]):
            GetObjectAt_1_T = VoxelGrid.GetObjectAt_MethodGroup.GetObjectAt_1_T1
            def __call__(self, cellPosition: Vec2Int, filter: Predicate_1[GetObjectAt_1_T] = ..., yPosition: typing.Optional[int] = ...) -> GetObjectAt_1_T:...

        @typing.overload
        def __call__(self, cellPosition: Vec2Int, filter: Predicate_1[GridObject] = ..., yPosition: typing.Optional[int] = ...) -> GridObject:...
        @typing.overload
        def __call__(self, cellPosition: Vec2Int, typeFilter: TypeIds, yPosition: typing.Optional[int] = ...) -> GridObject:...

    # Skipped GetObjectById due to it being static, abstract and generic.

    GetObjectById : GetObjectById_MethodGroup
    class GetObjectById_MethodGroup:
        def __getitem__(self, t:typing.Type[GetObjectById_1_T1]) -> GetObjectById_1[GetObjectById_1_T1]: ...

        GetObjectById_1_T1 = typing.TypeVar('GetObjectById_1_T1')
        class GetObjectById_1(typing.Generic[GetObjectById_1_T1]):
            GetObjectById_1_T = VoxelGrid.GetObjectById_MethodGroup.GetObjectById_1_T1
            def __call__(self, instanceId: typing.Optional[Guid]) -> GetObjectById_1_T:...

        def __call__(self, instanceId: Guid) -> GridObject:...

    # Skipped IsInRange due to it being static, abstract and generic.

    IsInRange : IsInRange_MethodGroup
    class IsInRange_MethodGroup:
        @typing.overload
        def __call__(self, gridPosition: Vec3Int) -> bool:...
        @typing.overload
        def __call__(self, gridPosition: Vec2Int) -> bool:...

    # Skipped LeaseObjectsOfType due to it being static, abstract and generic.

    LeaseObjectsOfType : LeaseObjectsOfType_MethodGroup
    class LeaseObjectsOfType_MethodGroup:
        def __getitem__(self, t:typing.Type[LeaseObjectsOfType_1_T1]) -> LeaseObjectsOfType_1[LeaseObjectsOfType_1_T1]: ...

        LeaseObjectsOfType_1_T1 = typing.TypeVar('LeaseObjectsOfType_1_T1')
        class LeaseObjectsOfType_1(typing.Generic[LeaseObjectsOfType_1_T1]):
            LeaseObjectsOfType_1_T = VoxelGrid.LeaseObjectsOfType_MethodGroup.LeaseObjectsOfType_1_T1
            def __call__(self, filter: Predicate_1[LeaseObjectsOfType_1_T] = ...) -> PooledList_1[LeaseObjectsOfType_1_T]:...


    # Skipped LeaseObjectsOfTypeAt due to it being static, abstract and generic.

    LeaseObjectsOfTypeAt : LeaseObjectsOfTypeAt_MethodGroup
    class LeaseObjectsOfTypeAt_MethodGroup:
        def __getitem__(self, t:typing.Type[LeaseObjectsOfTypeAt_1_T1]) -> LeaseObjectsOfTypeAt_1[LeaseObjectsOfTypeAt_1_T1]: ...

        LeaseObjectsOfTypeAt_1_T1 = typing.TypeVar('LeaseObjectsOfTypeAt_1_T1')
        class LeaseObjectsOfTypeAt_1(typing.Generic[LeaseObjectsOfTypeAt_1_T1]):
            LeaseObjectsOfTypeAt_1_T = VoxelGrid.LeaseObjectsOfTypeAt_MethodGroup.LeaseObjectsOfTypeAt_1_T1
            def __call__(self, cellPosition: Vec2Int, filter: Predicate_1[LeaseObjectsOfTypeAt_1_T] = ...) -> PooledList_1[LeaseObjectsOfTypeAt_1_T]:...


    # Skipped ToJson due to it being static, abstract and generic.

    ToJson : ToJson_MethodGroup
    class ToJson_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, grid: VoxelGrid) -> str:...



class VoxelGridExtensions(abc.ABC):
    @staticmethod
    def AreFaceToFace(gridObjectA: GridObject, gridObjectB: GridObject) -> bool: ...
    @staticmethod
    def CanOverlap(grid: VoxelGrid, id1: TypeIds, id2: TypeIds) -> bool: ...
    @staticmethod
    def RemoveFromGridImmediate(grid: VoxelGrid, obj: GridObject) -> None: ...
    @staticmethod
    def SetWaterLine(grid: VoxelGrid, waterline: int) -> None: ...
    @staticmethod
    def TrySetFloorHeightImmediateAt(grid: VoxelGrid, cellPosition: Vec2Int, newFloorHeight: typing.Optional[int]) -> bool: ...
    # Skipped PlaceOnImmediate due to it being static, abstract and generic.

    PlaceOnImmediate : PlaceOnImmediate_MethodGroup
    class PlaceOnImmediate_MethodGroup:
        def __getitem__(self, t:typing.Type[PlaceOnImmediate_1_T1]) -> PlaceOnImmediate_1[PlaceOnImmediate_1_T1]: ...

        PlaceOnImmediate_1_T1 = typing.TypeVar('PlaceOnImmediate_1_T1')
        class PlaceOnImmediate_1(typing.Generic[PlaceOnImmediate_1_T1]):
            PlaceOnImmediate_1_T = VoxelGridExtensions.PlaceOnImmediate_MethodGroup.PlaceOnImmediate_1_T1
            def __call__(self, grid: VoxelGrid, cell: Vec2Int) -> PlaceOnImmediate_1_T:...

        @typing.overload
        def __call__(self, grid: VoxelGrid, obj: GridObject, cell: Vec2Int) -> bool:...
        @typing.overload
        def __call__(self, grid: VoxelGrid, obj: GridObject, position: GridTransform) -> bool:...


