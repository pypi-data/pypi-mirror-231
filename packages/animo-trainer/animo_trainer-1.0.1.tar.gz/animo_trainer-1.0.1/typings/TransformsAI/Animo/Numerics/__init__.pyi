import typing, clr
from System import IFormattable, IEquatable_1, Array_1, IFormatProvider
from System.Numerics import Vector2, Vector3

class Vec2Int(IFormattable, IEquatable_1[Vec2Int]):
    def __init__(self, x: int, z: int) -> None: ...
    AdjacentDirections : Array_1[Vec2Int]
    UnitDirections : Array_1[Vec2Int]
    X : int
    Z : int
    @classmethod
    @property
    def Back(cls) -> Vec2Int: ...
    @classmethod
    @property
    def Forward(cls) -> Vec2Int: ...
    @property
    def IsAxisAligned(self) -> bool: ...
    @property
    def IsUnitDirection(self) -> bool: ...
    @property
    def Item(self) -> int: ...
    @Item.setter
    def Item(self, value: int) -> int: ...
    @classmethod
    @property
    def Left(cls) -> Vec2Int: ...
    @property
    def m_X(self) -> None: ...
    @m_X.setter
    def m_X(self, value: int) -> None: ...
    @property
    def m_Z(self) -> None: ...
    @m_Z.setter
    def m_Z(self, value: int) -> None: ...
    @property
    def Magnitude(self) -> float: ...
    @classmethod
    @property
    def One(cls) -> Vec2Int: ...
    @classmethod
    @property
    def Right(cls) -> Vec2Int: ...
    @property
    def SqrMagnitude(self) -> int: ...
    @property
    def X0Z(self) -> Vec3Int: ...
    @classmethod
    @property
    def Zero(cls) -> Vec2Int: ...
    @staticmethod
    def CeilToInt(v: Vector2) -> Vec2Int: ...
    def Clamp(self, min: Vec2Int, max: Vec2Int) -> None: ...
    def Deconstruct(self, x: clr.Reference[int], z: clr.Reference[int]) -> None: ...
    @staticmethod
    def Distance(a: Vec2Int, b: Vec2Int) -> float: ...
    @staticmethod
    def DistanceSqr(a: Vec2Int, b: Vec2Int) -> int: ...
    def DistanceSqrTo(self, b: Vec2Int) -> int: ...
    def DistanceTo(self, b: Vec2Int) -> float: ...
    @staticmethod
    def FloorToInt(v: Vector2) -> Vec2Int: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def ManhattanDistance(a: Vec2Int, b: Vec2Int) -> int: ...
    @staticmethod
    def Max(lhs: Vec2Int, rhs: Vec2Int) -> Vec2Int: ...
    @staticmethod
    def Min(lhs: Vec2Int, rhs: Vec2Int) -> Vec2Int: ...
    def __add__(self, a: Vec2Int, b: Vec2Int) -> Vec2Int: ...
    def __truediv__(self, a: Vec2Int, b: int) -> Vec2Int: ...
    def __eq__(self, lhs: Vec2Int, rhs: Vec2Int) -> bool: ...
    # Operator not supported op_Explicit(v: Vec2Int)
    # Operator not supported op_Implicit(d: Directions)
    # Operator not supported op_Implicit(tuple: ValueTuple`2)
    # Operator not supported op_Implicit(v: Vec2Int)
    # Operator not supported op_Implicit(v: Vec2Int)
    def __ne__(self, lhs: Vec2Int, rhs: Vec2Int) -> bool: ...
    @typing.overload
    def __mul__(self, a: int, b: Vec2Int) -> Vec2Int: ...
    @typing.overload
    def __mul__(self, a: Vec2Int, b: int) -> Vec2Int: ...
    @typing.overload
    def __mul__(self, a: Vec2Int, b: Vec2Int) -> Vec2Int: ...
    def __sub__(self, a: Vec2Int, b: Vec2Int) -> Vec2Int: ...
    def __neg__(self, v: Vec2Int) -> Vec2Int: ...
    def Rotate(self, angle: float) -> Vec2Int: ...
    @staticmethod
    def RoundToInt(v: Vector2) -> Vec2Int: ...
    def ToUnitDirection(self) -> Vec2Int: ...
    def WithY(self, y: int) -> Vec3Int: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Vec2Int) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped Scale due to it being static, abstract and generic.

    Scale : Scale_MethodGroup
    class Scale_MethodGroup:
        @typing.overload
        def __call__(self, scale: Vec2Int) -> None:...
        @typing.overload
        def __call__(self, a: Vec2Int, b: Vec2Int) -> Vec2Int:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class Vec3Int(IFormattable, IEquatable_1[Vec3Int]):
    def __init__(self, x: int, y: int, z: int) -> None: ...
    X : int
    Y : int
    Z : int
    @classmethod
    @property
    def Back(cls) -> Vec3Int: ...
    @classmethod
    @property
    def Down(cls) -> Vec3Int: ...
    @classmethod
    @property
    def Forward(cls) -> Vec3Int: ...
    @property
    def Item(self) -> int: ...
    @Item.setter
    def Item(self, value: int) -> int: ...
    @classmethod
    @property
    def Left(cls) -> Vec3Int: ...
    @property
    def m_X(self) -> None: ...
    @m_X.setter
    def m_X(self, value: int) -> None: ...
    @property
    def m_Y(self) -> None: ...
    @m_Y.setter
    def m_Y(self, value: int) -> None: ...
    @property
    def m_Z(self) -> None: ...
    @m_Z.setter
    def m_Z(self, value: int) -> None: ...
    @property
    def Magnitude(self) -> float: ...
    @classmethod
    @property
    def One(cls) -> Vec3Int: ...
    @classmethod
    @property
    def Right(cls) -> Vec3Int: ...
    @property
    def SqrMagnitude(self) -> int: ...
    @classmethod
    @property
    def Up(cls) -> Vec3Int: ...
    @property
    def XZ(self) -> Vec2Int: ...
    @classmethod
    @property
    def Zero(cls) -> Vec3Int: ...
    @staticmethod
    def CeilToInt(v: Vector3) -> Vec3Int: ...
    def Clamp(self, min: Vec3Int, max: Vec3Int) -> None: ...
    def ClampBounds(self, max: int) -> Vec3Int: ...
    def Deconstruct(self, x: clr.Reference[int], y: clr.Reference[int], z: clr.Reference[int]) -> None: ...
    @staticmethod
    def Distance(a: Vec3Int, b: Vec3Int) -> float: ...
    @staticmethod
    def DistanceSqr(a: Vec3Int, b: Vec3Int) -> float: ...
    @staticmethod
    def FloorToInt(v: Vector3) -> Vec3Int: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Max(lhs: Vec3Int, rhs: Vec3Int) -> Vec3Int: ...
    @staticmethod
    def Min(lhs: Vec3Int, rhs: Vec3Int) -> Vec3Int: ...
    def MinComponent(self) -> int: ...
    def NormalizedSafe(self) -> Vector3: ...
    def __add__(self, a: Vec3Int, b: Vec3Int) -> Vec3Int: ...
    def __truediv__(self, a: Vec3Int, b: int) -> Vec3Int: ...
    def __eq__(self, lhs: Vec3Int, rhs: Vec3Int) -> bool: ...
    # Operator not supported op_Explicit(v: Vec3Int)
    # Operator not supported op_Implicit(tuple: ValueTuple`3)
    # Operator not supported op_Implicit(v: Vec3Int)
    # Operator not supported op_Implicit(v: Vec2Int)
    def __ne__(self, lhs: Vec3Int, rhs: Vec3Int) -> bool: ...
    @typing.overload
    def __mul__(self, a: int, b: Vec3Int) -> Vec3Int: ...
    @typing.overload
    def __mul__(self, a: Vec3Int, b: int) -> Vec3Int: ...
    @typing.overload
    def __mul__(self, a: Vec3Int, b: Vec3Int) -> Vec3Int: ...
    def __sub__(self, a: Vec3Int, b: Vec3Int) -> Vec3Int: ...
    def __neg__(self, a: Vec3Int) -> Vec3Int: ...
    @staticmethod
    def RoundToInt(v: Vector3) -> Vec3Int: ...
    def ToUnitDirection(self) -> Vec3Int: ...
    def WithX(self, newX: int) -> Vec3Int: ...
    def WithY(self, newY: int) -> Vec3Int: ...
    def WithZ(self, newZ: int) -> Vec3Int: ...
    @staticmethod
    def XDelta(a: Vec3Int, b: Vec3Int) -> int: ...
    @staticmethod
    def YDelta(a: Vec3Int, b: Vec3Int) -> int: ...
    @staticmethod
    def ZDelta(a: Vec3Int, b: Vec3Int) -> int: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Vec3Int) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped Scale due to it being static, abstract and generic.

    Scale : Scale_MethodGroup
    class Scale_MethodGroup:
        @typing.overload
        def __call__(self, scale: Vec3Int) -> None:...
        @typing.overload
        def __call__(self, a: Vec3Int, b: Vec3Int) -> Vec3Int:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...


