import typing, clr
from TransformsAI.Animo.Rewards import TargetedReward, RewardTargetTypes, RewardTarget, Reward
from System import Array_1, IEquatable_1, ValueTuple_2, Guid
from TransformsAI.Animo.Intents import Intent, UseIntent
from TransformsAI.Animo import ObjectInfo, ObjectGroup, GridObject, IntentConflictResolver, Actor, HoldableObject, Directions, VoxelGrid, GridTransform
from TransformsAI.Animo.Constants import TypeIds, Effects
from System.Collections.Generic import List_1, HashSet_1
from TransformsAI.Animo.Numerics import Vec2Int, Vec3Int
from TransformsAI.Animo.HeuristicAI import HeuristicBehaviours
from TransformsAI.Animo.Rewards.Categories import RewardCategory
from TransformsAI.Animo.Tools import ReadOnlyArray_1

class CauseOtherCharacterToBecomeReward(TargetedReward):
    def __init__(self, categoryId: str, rewardId: str) -> None: ...
    @property
    def CanUserTargetSelf(self) -> bool: ...
    @property
    def CategoryId(self) -> str: ...
    @property
    def HasTarget(self) -> bool: ...
    @property
    def RewardId(self) -> str: ...
    @property
    def Targets(self) -> Array_1[RewardTargetTypes]: ...
    def EvaluateOnIntentExecute(self, character: CharacterObject, intentCausedByCharacter: Intent, target: RewardTarget) -> bool: ...


class CharacterInfo(ObjectInfo, IEquatable_1[CharacterInfo]):
    def __init__(self) -> None: ...
    @property
    def CanStepOnObjects(self) -> bool: ...
    @property
    def CreatesObjects(self) -> Array_1[TypeIds]: ...
    @property
    def IsDestroyedInDeepWater(self) -> bool: ...
    @property
    def IsDestroyedInShallowWater(self) -> bool: ...
    @property
    def IsDestructible(self) -> bool: ...
    @property
    def IsGrabbable(self) -> bool: ...
    @property
    def IsOccupier(self) -> bool: ...
    @property
    def IsUsableOnGrid(self) -> bool: ...
    @property
    def LabelName(self) -> str: ...
    @property
    def MaximumBurnAmount(self) -> int: ...
    @property
    def ObjectGroup(self) -> ObjectGroup: ...
    @property
    def TransformsInto(self) -> Array_1[TypeIds]: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    @property
    def TypeId(self) -> TypeIds: ...
    @property
    def UsePriority(self) -> float: ...
    def CanReceiveEffect(self, effect: Effects) -> bool: ...
    def CreateObject(self) -> GridObject: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: CharacterInfo, right: CharacterInfo) -> bool: ...
    def __ne__(self, left: CharacterInfo, right: CharacterInfo) -> bool: ...
    def RegisterConflictResolvers(self) -> List_1[ValueTuple_2[float, IntentConflictResolver]]: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: CharacterInfo) -> bool:...
        @typing.overload
        def __call__(self, other: ObjectInfo) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class CharacterObject(Actor):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, characterId: int, variantId: int) -> None: ...
    Info : ObjectInfo
    LastTurnHeldObject : HoldableObject
    @property
    def ActionTaken(self) -> CharacterObject.Actions: ...
    @ActionTaken.setter
    def ActionTaken(self, value: CharacterObject.Actions) -> CharacterObject.Actions: ...
    @property
    def BurnAmount(self) -> int: ...
    @property
    def Cell(self) -> Vec2Int: ...
    @property
    def CharacterId(self) -> int: ...
    @CharacterId.setter
    def CharacterId(self, value: int) -> int: ...
    @property
    def CharacterUsedThisTurn(self) -> CharacterObject: ...
    @property
    def Container(self) -> GridObject: ...
    @Container.setter
    def Container(self, value: GridObject) -> GridObject: ...
    @property
    def ContinuousUseItem(self) -> GridObject: ...
    @ContinuousUseItem.setter
    def ContinuousUseItem(self, value: GridObject) -> GridObject: ...
    @property
    def DidContinueUse(self) -> bool: ...
    @DidContinueUse.setter
    def DidContinueUse(self, value: bool) -> bool: ...
    @property
    def DidDropFail(self) -> bool: ...
    @property
    def DidGrabFail(self) -> bool: ...
    @property
    def DidUseNothing(self) -> bool: ...
    @property
    def DidWalkFail(self) -> bool: ...
    @property
    def DidWalkForward(self) -> bool: ...
    @property
    def Direction(self) -> Directions: ...
    @property
    def ForceHeuristicBehaviour(self) -> bool: ...
    @ForceHeuristicBehaviour.setter
    def ForceHeuristicBehaviour(self, value: bool) -> bool: ...
    @property
    def Grid(self) -> VoxelGrid: ...
    @property
    def Height(self) -> int: ...
    @property
    def HeldObject(self) -> HoldableObject: ...
    @property
    def HeuristicBehaviour(self) -> HeuristicBehaviours: ...
    @HeuristicBehaviour.setter
    def HeuristicBehaviour(self, value: HeuristicBehaviours) -> HeuristicBehaviours: ...
    @property
    def InstanceId(self) -> Guid: ...
    @property
    def IntentsFiredThisTurn(self) -> List_1[Intent]: ...
    @property
    def IsHelpless(self) -> bool: ...
    @property
    def IsInDeepWater(self) -> bool: ...
    @property
    def IsInShallowWater(self) -> bool: ...
    @property
    def IsOnGrid(self) -> bool: ...
    @property
    def IsStoodUpon(self) -> bool: ...
    @property
    def IsStunned(self) -> bool: ...
    @IsStunned.setter
    def IsStunned(self, value: bool) -> bool: ...
    @property
    def MainIntent(self) -> Intent: ...
    @property
    def NextAction(self) -> typing.Optional[CharacterObject.Actions]: ...
    @NextAction.setter
    def NextAction(self, value: typing.Optional[CharacterObject.Actions]) -> typing.Optional[CharacterObject.Actions]: ...
    @property
    def ObjectUsedThisTurn(self) -> GridObject: ...
    @property
    def OriginalInstanceId(self) -> Guid: ...
    @property
    def Position(self) -> Vec3Int: ...
    @property
    def State(self) -> CharacterObject.States: ...
    @property
    def StateObservation(self) -> ValueTuple_2[float, float]: ...
    @property
    def Transform(self) -> GridTransform: ...
    @Transform.setter
    def Transform(self, value: GridTransform) -> GridTransform: ...
    @property
    def TransformedInto(self) -> GridObject: ...
    @property
    def TransformOnGrid(self) -> None: ...
    @TransformOnGrid.setter
    def TransformOnGrid(self, value: typing.Optional[GridTransform]) -> None: ...
    @property
    def TypeId(self) -> TypeIds: ...
    @property
    def UsedIntent(self) -> UseIntent: ...
    @property
    def UsedItem(self) -> GridObject: ...
    @property
    def VariantId(self) -> int: ...
    @VariantId.setter
    def VariantId(self, value: int) -> int: ...
    @property
    def WasDestroyedOrTransformed(self) -> bool: ...
    def CanWalkForward(self) -> bool: ...
    @staticmethod
    def CanWalkThrough(grid: VoxelGrid, fromCell: Vec2Int, toCell: Vec2Int) -> bool: ...
    def Flinch(self) -> None: ...
    def GetTapOverrideIntent(self, actor: Actor) -> Intent: ...
    def OnAfterStep(self) -> None: ...
    def OnEffect(self, effect: Effects, source: GridObject, outIntents: List_1[Intent]) -> bool: ...
    def Stun(self, onChangeCharacterStateIntent: clr.Reference[OnCharacterStateChangedIntent]) -> None: ...
    def UnStun(self, onChangeCharacterStateIntent: clr.Reference[OnCharacterStateChangedIntent]) -> None: ...

    class Actions(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Wait : CharacterObject.Actions # 0
        Forward : CharacterObject.Actions # 1
        TurnRight : CharacterObject.Actions # 2
        TurnLeft : CharacterObject.Actions # 3
        TurnAround : CharacterObject.Actions # 4
        Grab : CharacterObject.Actions # 5
        Use : CharacterObject.Actions # 6


    class States(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        None_ : CharacterObject.States # 0
        Ok : CharacterObject.States # 1
        InDeepWater : CharacterObject.States # 2
        Stunned : CharacterObject.States # 3
        Hypnotized : CharacterObject.States # 4



class CharacterRewards(RewardCategory):
    def __init__(self) -> None: ...
    CauseOtherCharacterToBecome : CauseOtherCharacterToBecomeReward
    Hug : HugReward
    name : str
    @property
    def AssociatedObject(self) -> typing.Optional[TypeIds]: ...
    @property
    def CategoryId(self) -> str: ...
    @property
    def Rewards(self) -> ReadOnlyArray_1[Reward]: ...


class FlinchIntent(Intent):
    def __init__(self) -> None: ...
    Causers : HashSet_1[GridObject]
    id : int
    @property
    def ChildIntents(self) -> List_1[Intent]: ...
    @property
    def Grid(self) -> VoxelGrid: ...
    @property
    def IntentState(self) -> Intent.States: ...
    @property
    def Priority(self) -> float: ...
    @property
    def Source(self) -> GridObject: ...


class HugCharacterIntent(UseIntent):
    def __init__(self) -> None: ...
    Causers : HashSet_1[GridObject]
    HuggedCharacter : CharacterObject
    id : int
    @property
    def ChildIntents(self) -> List_1[Intent]: ...
    @property
    def DidSucceed(self) -> bool: ...
    @property
    def Grid(self) -> VoxelGrid: ...
    @property
    def IntentState(self) -> Intent.States: ...
    @property
    def Priority(self) -> float: ...
    @property
    def Source(self) -> GridObject: ...
    @property
    def User(self) -> Actor: ...
    @User.setter
    def User(self, value: Actor) -> Actor: ...
    @property
    def WillContinueUsing(self) -> bool: ...


class HugReward(TargetedReward):
    def __init__(self, categoryId: str, rewardId: str) -> None: ...
    @property
    def CanUserTargetSelf(self) -> bool: ...
    @property
    def CategoryId(self) -> str: ...
    @property
    def HasTarget(self) -> bool: ...
    @property
    def RewardId(self) -> str: ...
    @property
    def Targets(self) -> Array_1[RewardTargetTypes]: ...
    def EvaluateOnIntentExecute(self, character: CharacterObject, intentCausedByCharacter: Intent, target: RewardTarget) -> bool: ...


class OnCharacterStateChangedIntent(Intent):
    def __init__(self) -> None: ...
    Causers : HashSet_1[GridObject]
    id : int
    NewState : CharacterObject.States
    @property
    def ChildIntents(self) -> List_1[Intent]: ...
    @property
    def Grid(self) -> VoxelGrid: ...
    @property
    def IntentState(self) -> Intent.States: ...
    @property
    def Priority(self) -> float: ...
    @property
    def Source(self) -> GridObject: ...


class WaitIntent(Intent):
    def __init__(self) -> None: ...
    Causers : HashSet_1[GridObject]
    id : int
    @property
    def ChildIntents(self) -> List_1[Intent]: ...
    @property
    def Grid(self) -> VoxelGrid: ...
    @property
    def IntentState(self) -> Intent.States: ...
    @property
    def Priority(self) -> float: ...
    @property
    def Source(self) -> GridObject: ...

