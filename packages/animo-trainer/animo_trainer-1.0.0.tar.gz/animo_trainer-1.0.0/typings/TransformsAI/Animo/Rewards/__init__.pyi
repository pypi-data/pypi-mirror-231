import typing, abc
from TransformsAI.Animo.Constants import TypeIds, GroundMaterials
from TransformsAI.Animo.Objects.Character import CharacterObject
from TransformsAI.Animo.Intents import Intent
from TransformsAI.Animo import ISimulationObserver, VoxelGrid, GridObject, ObjectInfo
from System.Collections.Generic import List_1
from TransformsAI.Animo.Tools import ReadOnlyList_1
from TransformsAI.Animo.Rewards.Categories import RewardCategory
from System import IEquatable_1, Array_1
from TransformsAI.Animo.Numerics import Vec2Int

class ObjectDestroyedReward(Reward):
    def __init__(self, categoryId: str, rewardId: str, id: TypeIds) -> None: ...
    @property
    def CategoryId(self) -> str: ...
    @property
    def HasTarget(self) -> bool: ...
    @property
    def RewardId(self) -> str: ...
    def EvaluateOnIntentExecute(self, characterObject: CharacterObject, intentCausedByCharacter: Intent, target: typing.Optional[RewardTarget]) -> bool: ...


class Reward(abc.ABC):
    @property
    def CategoryId(self) -> str: ...
    @property
    def HasTarget(self) -> bool: ...
    @property
    def RewardId(self) -> str: ...
    def EvaluateAfterStep(self, character: CharacterObject, target: typing.Optional[RewardTarget]) -> bool: ...
    def EvaluateOnIntentExecute(self, character: CharacterObject, intentCausedByCharacter: Intent, target: typing.Optional[RewardTarget]) -> bool: ...
    def ToString(self) -> str: ...


class RewardAmounts(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : RewardAmounts # 0
    Plus1 : RewardAmounts # 1
    Plus10 : RewardAmounts # 10
    Plus100 : RewardAmounts # 100
    Minus100 : RewardAmounts # -100
    Minus10 : RewardAmounts # -10
    Minus1 : RewardAmounts # -1


class RewardEvaluator(ISimulationObserver):
    def __init__(self, characterId: int, rewardFunctions: List_1[RewardFunction]) -> None: ...
    @property
    def CharacterId(self) -> int: ...
    @CharacterId.setter
    def CharacterId(self, value: int) -> int: ...
    @property
    def Rewards(self) -> ReadOnlyList_1[RewardFunction]: ...
    def ClearExecutionCounts(self) -> None: ...
    def GetTotalNegativeReward(self) -> float: ...
    def GetTotalPositiveReward(self) -> float: ...
    def GetTotalRewardThisStep(self) -> float: ...
    def OnIntentExecuted(self, intent: Intent) -> None: ...
    def OnStepCompleted(self, grid: VoxelGrid) -> None: ...
    def SetRewardCount(self, numRewards: int) -> None: ...
    def SetRewardFunction(self, index: int, rewardFunction: RewardFunction) -> None: ...
    def SetRewards(self, agentDataCurrentRewards: List_1[RewardFunction]) -> None: ...
    # Skipped GetExecutionCount due to it being static, abstract and generic.

    GetExecutionCount : GetExecutionCount_MethodGroup
    class GetExecutionCount_MethodGroup:
        @typing.overload
        def __call__(self, rewardFunctionIndex: int) -> int:...
        @typing.overload
        def __call__(self, rewardFunction: RewardFunction) -> int:...



class RewardFunction:
    def __init__(self) -> None: ...
    @property
    def Category(self) -> RewardCategory: ...
    @Category.setter
    def Category(self, value: RewardCategory) -> RewardCategory: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Reward(self) -> Reward: ...
    @Reward.setter
    def Reward(self, value: Reward) -> Reward: ...
    @property
    def RewardAmount(self) -> RewardAmounts: ...
    @RewardAmount.setter
    def RewardAmount(self, value: RewardAmounts) -> RewardAmounts: ...
    @property
    def Scale(self) -> int: ...
    @property
    def Target(self) -> typing.Optional[RewardTarget]: ...
    @Target.setter
    def Target(self, value: typing.Optional[RewardTarget]) -> typing.Optional[RewardTarget]: ...
    def EvaluateAfterStep(self, character: CharacterObject) -> bool: ...
    def EvaluateOnIntentExecute(self, character: CharacterObject, justExecutedIntent: Intent) -> bool: ...
    def ToString(self) -> str: ...


class RewardTarget(IEquatable_1[RewardTarget]):
    def __init__(self, type: RewardTargetTypes, id: int) -> None: ...
    @property
    def CharacterTarget(self) -> int: ...
    @property
    def GroundTarget(self) -> GroundMaterials: ...
    @property
    def HeightTarget(self) -> int: ...
    @property
    def Id(self) -> int: ...
    @property
    def ObjectTypeTarget(self) -> TypeIds: ...
    @property
    def StateTarget(self) -> CharacterObject.States: ...
    @property
    def Type(self) -> RewardTargetTypes: ...
    @staticmethod
    def AnyCharacter() -> RewardTarget: ...
    @staticmethod
    def Anything() -> RewardTarget: ...
    @staticmethod
    def Autonimo() -> RewardTarget: ...
    @staticmethod
    def Block() -> RewardTarget: ...
    @staticmethod
    def Character(characterId: int) -> RewardTarget: ...
    @staticmethod
    def Fail() -> RewardTarget: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Ground(ground: GroundMaterials) -> RewardTarget: ...
    @staticmethod
    def Height(height: int) -> RewardTarget: ...
    @staticmethod
    def Nothing() -> RewardTarget: ...
    @staticmethod
    def ObjectType(typeId: TypeIds) -> RewardTarget: ...
    def __eq__(self, left: RewardTarget, right: RewardTarget) -> bool: ...
    def __ne__(self, left: RewardTarget, right: RewardTarget) -> bool: ...
    @staticmethod
    def State(state: CharacterObject.States) -> RewardTarget: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: RewardTarget) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class RewardTargetTypes(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Anything : RewardTargetTypes # 0
    ObjectType : RewardTargetTypes # 1
    GroundTargets : RewardTargetTypes # 2
    Characters : RewardTargetTypes # 3
    Block : RewardTargetTypes # 4
    States : RewardTargetTypes # 5
    Heights : RewardTargetTypes # 6
    Nothing : RewardTargetTypes # 7
    Fail : RewardTargetTypes # 8


class TargetedReward(Reward):
    MaxClosestSearchDistance : float
    @property
    def CanUserTargetSelf(self) -> bool: ...
    @property
    def CategoryId(self) -> str: ...
    @property
    def HasTarget(self) -> bool: ...
    @property
    def RewardId(self) -> str: ...
    @property
    def Targets(self) -> Array_1[RewardTargetTypes]: ...
    @staticmethod
    def CheckBesideTarget(grid: VoxelGrid, cell: Vec2Int, target: RewardTarget) -> bool: ...
    @staticmethod
    def CheckTargetCharacter(gridObject: GridObject, target: RewardTarget, characterObjectToIgnore: CharacterObject = ...) -> bool: ...
    @staticmethod
    def FilterCharacterByTarget(gridObject: GridObject, target: RewardTarget, characterObjectToIgnore: CharacterObject = ...) -> CharacterObject: ...
    def GetTargetGridObjectClosestToCharacter(self, characterObject: CharacterObject, rewardTarget: RewardTarget, gridObjectToIgnore: GridObject = ..., MaxClosestSearchDistance: float = ...) -> GridObject: ...
    def TargetGroundMaterialFilter(self, groundMat: GroundMaterials) -> bool: ...
    def TargetHeightsFilter(self, height: int) -> bool: ...
    def TargetObjectTypeFilter(self, obj: ObjectInfo) -> bool: ...
    # Skipped EvaluateAfterStep due to it being static, abstract and generic.

    EvaluateAfterStep : EvaluateAfterStep_MethodGroup
    class EvaluateAfterStep_MethodGroup:
        @typing.overload
        def __call__(self, character: CharacterObject, target: typing.Optional[RewardTarget]) -> bool:...
        @typing.overload
        def __call__(self, character: CharacterObject, target: RewardTarget) -> bool:...

    # Skipped EvaluateOnIntentExecute due to it being static, abstract and generic.

    EvaluateOnIntentExecute : EvaluateOnIntentExecute_MethodGroup
    class EvaluateOnIntentExecute_MethodGroup:
        @typing.overload
        def __call__(self, character: CharacterObject, intentCausedByCharacter: Intent, target: typing.Optional[RewardTarget]) -> bool:...
        @typing.overload
        def __call__(self, character: CharacterObject, intentCausedByCharacter: Intent, target: RewardTarget) -> bool:...


