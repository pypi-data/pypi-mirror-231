# coding: utf-8


"""
IGNORE:
    Nutanix Clustermgmt Versioned APIs

    Manage Hosts, Clusters and other Infrastructure.  # noqa: E501

    OpenAPI spec version: 4.0.1-beta-1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
IGNORE
"""
from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from ntnx_clustermgmt_py_client.api_client import ApiClient


class ClusterApi(object):
    """IGNORE:
    NOTE: A placeholder for class level description
    IGNORE
    """  # noqa: E501

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()

        self.api_client = api_client
        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }

    def add_node(self, extId, body, **kwargs):  # noqa: E501
        """Add node on a cluster.

        >>> response = api.add_node(extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.add_node(extId, body, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param body: Property of the node to be added
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.ExpandClusterParams`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.AddNodeTaskResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `add_node`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/$actions/expand-cluster', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.AddNodeTaskResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/$actions/expand-cluster', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.AddNodeTaskResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def add_rsyslog_server(self, extId, body, **kwargs):  # noqa: E501
        """Add new RSYSLOG server configuration

        >>> response = api.add_rsyslog_server(extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.add_rsyslog_server(extId, body, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param body: RSYSLOG server to add
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.RsyslogServer`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.AddRsyslogServerTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `add_rsyslog_server`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_rsyslog_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/rsyslog-servers', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.AddRsyslogServerTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/rsyslog-servers', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.AddRsyslogServerTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def add_snmp_transport(self, extId, body, **kwargs):  # noqa: E501
        """Add SNMP transports

        >>> response = api.add_snmp_transport(extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.add_snmp_transport(extId, body, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param body: SNMP transports to add
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.SnmpTransport`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.AddSnmpTransportsTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `add_snmp_transport`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_snmp_transport`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/snmp/$actions/add-transports', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.AddSnmpTransportsTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/snmp/$actions/add-transports', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.AddSnmpTransportsTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def add_snmp_trap(self, extId, body, **kwargs):  # noqa: E501
        """Add SNMP trap

        >>> response = api.add_snmp_trap(extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.add_snmp_trap(extId, body, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param body: SNMP trap to add
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.SnmpTrap`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.AddSnmpTrapTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `add_snmp_trap`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_snmp_trap`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/snmp/traps', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.AddSnmpTrapTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/snmp/traps', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.AddSnmpTrapTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def add_snmp_user(self, extId, body, **kwargs):  # noqa: E501
        """Add SNMP user

        >>> response = api.add_snmp_user(extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.add_snmp_user(extId, body, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param body: SNMP user to add
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.SnmpUser`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.AddSnmpUserTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `add_snmp_user`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_snmp_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/snmp/users', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.AddSnmpUserTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/snmp/users', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.AddSnmpUserTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def create_cluster(self, body, **kwargs):  # noqa: E501
        """Create a cluster

        >>> response = api.create_cluster(body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.create_cluster(body, async_req=True)
        >>> result = thread.get()

        :param body: The required parameters for cluster create workflow
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.Cluster`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.ClusterCreateTaskResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.ClusterCreateTaskResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.ClusterCreateTaskResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def delete_rsyslog_server(self, clusterExtId, extId, **kwargs):  # noqa: E501
        """Delete RSYSLOG Server

        >>> response = api.delete_rsyslog_server(clusterExtId, extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.delete_rsyslog_server(clusterExtId, extId, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param extId: RSYSLOG server UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.DeleteRsyslogServerTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `delete_rsyslog_server`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `delete_rsyslog_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/rsyslog-servers/{extId}', 'DELETE',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.DeleteRsyslogServerTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/rsyslog-servers/{extId}', 'DELETE',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.DeleteRsyslogServerTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def delete_snmp_trap(self, clusterExtId, extId, **kwargs):  # noqa: E501
        """Delete SNMP trap

        >>> response = api.delete_snmp_trap(clusterExtId, extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.delete_snmp_trap(clusterExtId, extId, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param extId: SNMP trap UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.DeleteSnmpTrapTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `delete_snmp_trap`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `delete_snmp_trap`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/snmp/traps/{extId}', 'DELETE',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.DeleteSnmpTrapTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/snmp/traps/{extId}', 'DELETE',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.DeleteSnmpTrapTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def delete_snmp_user(self, clusterExtId, extId, **kwargs):  # noqa: E501
        """Delete SNMP user

        >>> response = api.delete_snmp_user(clusterExtId, extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.delete_snmp_user(clusterExtId, extId, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param extId: SNMP user UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.DeleteSnmpUserTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `delete_snmp_user`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `delete_snmp_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/snmp/users/{extId}', 'DELETE',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.DeleteSnmpUserTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/snmp/users/{extId}', 'DELETE',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.DeleteSnmpUserTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def discover_unconfigured_nodes(self, extId, body, **kwargs):  # noqa: E501
        """Discover unconfigured nodes

        >>> response = api.discover_unconfigured_nodes(extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.discover_unconfigured_nodes(extId, body, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param body: Discover unconfigured node details
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.NodeDiscoveryParams`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.DiscoverNodeTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `discover_unconfigured_nodes`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `discover_unconfigured_nodes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/$actions/discover-unconfigured-nodes', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.DiscoverNodeTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/$actions/discover-unconfigured-nodes', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.DiscoverNodeTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_all_hosts(self, _page=None, _limit=None, _filter=None, _orderby=None, _apply=None, _select=None, **kwargs):  # noqa: E501
        """Get all host entities

        >>> response = api.get_all_hosts((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _apply, (optional) _select)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_all_hosts(async_req=True)
        >>> result = thread.get()

        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
        :type _page:
            :class:`int`
        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
        :type _limit:
            :class:`int`
        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - bootTimeUsecs - cluster/name - cluster/uuid - cpuCapacityHz - cpuFrequencyHz - cpuModel - defaultVhdContainerUuid - defaultVhdLocation - defaultVmContainerUuid - defaultVmLocation - gpuDriverVersion - gpuList - hostName - hypervisor/type - memorySizeBytes - numberOfCpuCores - numberOfCpuSockets - numberOfCpuThreads 
        :type _filter:
            :class:`str`
        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - cluster/name - controllerVm/externalAddress/ipv4/value - controllerVm/externalAddress/ipv6/value - hostName - hostType - hypervisor/type - memorySizeBytes 
        :type _orderby:
            :class:`str`
        :param _apply: A URL query parameter that allows clients to specify a sequence of transformations to the entity set, such as groupby, filter, aggregate etc. As of now only support for groupby exists.For example '$apply=groupby((templateName))' would get all templates grouped by templateName. The groupby can be applied on the following fields: - cluster/name - hypervisor/type 
        :type _apply:
            :class:`str`
        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. - blockModel - blockSerial - bootTimeUsecs - cluster - cpuCapacityHz - cpuFrequencyHz - cpuModel - defaultVhdContainerUuid - defaultVhdLocation - defaultVmContainerUuid - defaultVmLocation - failoverClusterFqdn - failoverClusterNodeStatus - gpuDriverVersion - gpuList - hostName - hostType - maintenanceState - memorySizeBytes - nodeStatus - numberOfCpuCores - numberOfCpuSockets - numberOfCpuThreads - rebootPending 
        :type _select:
            :class:`str`
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetAllHostsResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']


        collection_formats = {}

        path_params = {}

        query_params = []
        if '_page' in params and params['_page'] is not None:
            query_params.append(('$page', params['_page']))  # noqa: E501
        if '_limit' in params and params['_limit'] is not None:
            query_params.append(('$limit', params['_limit']))  # noqa: E501
        if '_filter' in params and params['_filter'] is not None:
            query_params.append(('$filter', params['_filter']))  # noqa: E501
        if '_orderby' in params and params['_orderby'] is not None:
            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
        if '_apply' in params and params['_apply'] is not None:
            query_params.append(('$apply', params['_apply']))  # noqa: E501
        if '_select' in params and params['_select'] is not None:
            query_params.append(('$select', params['_select']))  # noqa: E501

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['_page', '_limit', '_filter', '_orderby', '_apply', '_select'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/hosts', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetAllHostsResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/hosts', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetAllHostsResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_cluster(self, extId, **kwargs):  # noqa: E501
        """Get cluster entity

        >>> response = api.get_cluster(extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_cluster(extId, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetClusterResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetClusterResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetClusterResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_cluster_stats_info(self, clusterExtId, _startTime=None, _endTime=None, _samplingInterval=None, _statType=None, **kwargs):  # noqa: E501
        """Get cluster statistics

        >>> response = api.get_cluster_stats_info(clusterExtId, (optional) _startTime, (optional) _endTime, (optional) _samplingInterval, (optional) _statType)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_cluster_stats_info(clusterExtId, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param _startTime: The start time of the period for which stats should be reported. The value should be in extended ISO-8601 format. For example, start time of 2022-04-23T01:23:45.678+09:00 would consider all stats starting at 1:23:45.678 on the 23rd of April 2022. Details around ISO-8601 format can be found at https://www.iso.org/standard/70907.html 
        :type _startTime:
            :class:`str`
        :param _endTime: The end time of the period for which stats should be reported. The value should be in extended ISO-8601 format. For example, end time of 2022-04-23T013:23:45.678+09:00 would consider all stats till 13:23:45 .678 on the 23rd of April 2022. Details around ISO-8601 format can be found at https://www.iso.org/standard/70907.html 
        :type _endTime:
            :class:`str`
        :param _samplingInterval: The sampling interval in seconds at which statistical data should be collected For example, do you want performance statistics every 30 seconds? Every 60 seconds? 
        :type _samplingInterval:
            :class:`int`
        :param _statType: 
        :type _statType:
            :class:`common.v1.stats.DownSamplingOperator`
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.stats.ClusterStatsInfoApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `get_cluster_stats_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501

        query_params = []
        if '_startTime' in params and params['_startTime'] is not None:
            query_params.append(('$startTime', params['_startTime']))  # noqa: E501
        if '_endTime' in params and params['_endTime'] is not None:
            query_params.append(('$endTime', params['_endTime']))  # noqa: E501
        if '_samplingInterval' in params and params['_samplingInterval'] is not None:
            query_params.append(('$samplingInterval', params['_samplingInterval']))  # noqa: E501
        if '_statType' in params and params['_statType'] is not None:
            query_params.append(('$statType', params['_statType']))  # noqa: E501

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', '_startTime', '_endTime', '_samplingInterval', '_statType'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/stats/clusters/{clusterExtId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.stats.ClusterStatsInfoApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/stats/clusters/{clusterExtId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.stats.ClusterStatsInfoApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_clusters(self, _page=None, _limit=None, _filter=None, _orderby=None, _apply=None, _select=None, **kwargs):  # noqa: E501
        """Get cluster entities

        >>> response = api.get_clusters((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _apply, (optional) _select)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_clusters(async_req=True)
        >>> result = thread.get()

        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
        :type _page:
            :class:`int`
        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
        :type _limit:
            :class:`int`
        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - config/buildInfo/version - config/encryptionInTransitStatus - config/encryptionOption - config/encryptionScope - config/hypervisorTypes - extId - name - network/keyManagementServerType - upgradeStatus 
        :type _filter:
            :class:`str`
        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - config/buildInfo/version - config/encryptionOption - config/encryptionScope - config/hypervisorTypes - inefficientVmCount - name - network/keyManagementServerType - nodes/numberOfNodes - upgradeStatus - vmCount 
        :type _orderby:
            :class:`str`
        :param _apply: A URL query parameter that allows clients to specify a sequence of transformations to the entity set, such as groupby, filter, aggregate etc. As of now only support for groupby exists.For example '$apply=groupby((templateName))' would get all templates grouped by templateName. The groupby can be applied on the following fields: - config/buildInfo/version - nodes/numberOfNodes 
        :type _apply:
            :class:`str`
        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. - inefficientVmCount - name - upgradeStatus - vmCount 
        :type _select:
            :class:`str`
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetClustersResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']


        collection_formats = {}

        path_params = {}

        query_params = []
        if '_page' in params and params['_page'] is not None:
            query_params.append(('$page', params['_page']))  # noqa: E501
        if '_limit' in params and params['_limit'] is not None:
            query_params.append(('$limit', params['_limit']))  # noqa: E501
        if '_filter' in params and params['_filter'] is not None:
            query_params.append(('$filter', params['_filter']))  # noqa: E501
        if '_orderby' in params and params['_orderby'] is not None:
            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
        if '_apply' in params and params['_apply'] is not None:
            query_params.append(('$apply', params['_apply']))  # noqa: E501
        if '_select' in params and params['_select'] is not None:
            query_params.append(('$select', params['_select']))  # noqa: E501

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['_page', '_limit', '_filter', '_orderby', '_apply', '_select'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetClustersResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetClustersResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_domain_fault_tolerance_status(self, extId, **kwargs):  # noqa: E501
        """Get domain fault tolerance status

        >>> response = api.get_domain_fault_tolerance_status(extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_domain_fault_tolerance_status(extId, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetDomainFaultToleranceResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_domain_fault_tolerance_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/fault-tolerance-status', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetDomainFaultToleranceResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/fault-tolerance-status', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetDomainFaultToleranceResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_host(self, clusterExtId, extId, **kwargs):  # noqa: E501
        """Get host entity

        >>> response = api.get_host(clusterExtId, extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_host(clusterExtId, extId, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param extId: Host UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetHostResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `get_host`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_host`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/hosts/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetHostResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/hosts/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetHostResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_host_nic(self, clusterExtId, hostExtId, extId, **kwargs):  # noqa: E501
        """Get host NIC

        >>> response = api.get_host_nic(clusterExtId, hostExtId, extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_host_nic(clusterExtId, hostExtId, extId, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param hostExtId: Host UUID
        :type hostExtId:
            :class:`str`, required
        :param extId: Host NIC UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetHostNicResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `get_host_nic`")  # noqa: E501
        # verify the required parameter 'hostExtId' is set
        if ('hostExtId' not in params or params['hostExtId'] is None):
            raise ValueError("Missing the required parameter `hostExtId` when calling `get_host_nic`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_host_nic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'hostExtId' in params and params['hostExtId'] is not None:
            path_params['hostExtId'] = params['hostExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'hostExtId', 'extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/hosts/{hostExtId}/host-nics/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetHostNicResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/hosts/{hostExtId}/host-nics/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetHostNicResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_host_nics(self, clusterExtId, extId, _page=None, _limit=None, _filter=None, _orderby=None, _select=None, **kwargs):  # noqa: E501
        """Get host NICs

        >>> response = api.get_host_nics(clusterExtId, extId, (optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_host_nics(clusterExtId, extId, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param extId: Host UUID
        :type extId:
            :class:`str`, required
        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
        :type _page:
            :class:`int`
        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
        :type _limit:
            :class:`int`
        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - dhcpEnabled - discoveryProtocol - interfaceStatus - linkSpeedInKbps - macAddress - mtuInBytes - name - nodeUuid - rxRingSizeInBytes - switchDeviceId - switchMacAddress - switchManagementIp/ipv4/value - switchManagementIp/ipv6/value - switchPortId - switchVlanId - txRingSizeInBytes 
        :type _filter:
            :class:`str`
        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - name 
        :type _orderby:
            :class:`str`
        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. - dhcpEnabled - discoveryProtocol - hostDescription - interfaceStatus - linkSpeedInKbps - macAddress - mtuInBytes - name - nodeUuid - rxRingSizeInBytes - switchDeviceId - switchMacAddress - switchManagementIp - switchPortId - switchVlanId - txRingSizeInBytes 
        :type _select:
            :class:`str`
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetHostNicsResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `get_host_nics`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_host_nics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []
        if '_page' in params and params['_page'] is not None:
            query_params.append(('$page', params['_page']))  # noqa: E501
        if '_limit' in params and params['_limit'] is not None:
            query_params.append(('$limit', params['_limit']))  # noqa: E501
        if '_filter' in params and params['_filter'] is not None:
            query_params.append(('$filter', params['_filter']))  # noqa: E501
        if '_orderby' in params and params['_orderby'] is not None:
            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
        if '_select' in params and params['_select'] is not None:
            query_params.append(('$select', params['_select']))  # noqa: E501

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'extId', '_page', '_limit', '_filter', '_orderby', '_select'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/hosts/{extId}/host-nics', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetHostNicsResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/hosts/{extId}/host-nics', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetHostNicsResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_host_stats_info(self, clusterExtId, hostExtId, _startTime=None, _endTime=None, _samplingInterval=None, _statType=None, **kwargs):  # noqa: E501
        """Get host statistics

        >>> response = api.get_host_stats_info(clusterExtId, hostExtId, (optional) _startTime, (optional) _endTime, (optional) _samplingInterval, (optional) _statType)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_host_stats_info(clusterExtId, hostExtId, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param hostExtId: Host UUID
        :type hostExtId:
            :class:`str`, required
        :param _startTime: The start time of the period for which stats should be reported. The value should be in extended ISO-8601 format. For example, start time of 2022-04-23T01:23:45.678+09:00 would consider all stats starting at 1:23:45.678 on the 23rd of April 2022. Details around ISO-8601 format can be found at https://www.iso.org/standard/70907.html 
        :type _startTime:
            :class:`str`
        :param _endTime: The end time of the period for which stats should be reported. The value should be in extended ISO-8601 format. For example, end time of 2022-04-23T013:23:45.678+09:00 would consider all stats till 13:23:45 .678 on the 23rd of April 2022. Details around ISO-8601 format can be found at https://www.iso.org/standard/70907.html 
        :type _endTime:
            :class:`str`
        :param _samplingInterval: The sampling interval in seconds at which statistical data should be collected For example, do you want performance statistics every 30 seconds? Every 60 seconds? 
        :type _samplingInterval:
            :class:`int`
        :param _statType: 
        :type _statType:
            :class:`common.v1.stats.DownSamplingOperator`
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.stats.HostStatsInfoApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `get_host_stats_info`")  # noqa: E501
        # verify the required parameter 'hostExtId' is set
        if ('hostExtId' not in params or params['hostExtId'] is None):
            raise ValueError("Missing the required parameter `hostExtId` when calling `get_host_stats_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'hostExtId' in params and params['hostExtId'] is not None:
            path_params['hostExtId'] = params['hostExtId']  # noqa: E501

        query_params = []
        if '_startTime' in params and params['_startTime'] is not None:
            query_params.append(('$startTime', params['_startTime']))  # noqa: E501
        if '_endTime' in params and params['_endTime'] is not None:
            query_params.append(('$endTime', params['_endTime']))  # noqa: E501
        if '_samplingInterval' in params and params['_samplingInterval'] is not None:
            query_params.append(('$samplingInterval', params['_samplingInterval']))  # noqa: E501
        if '_statType' in params and params['_statType'] is not None:
            query_params.append(('$statType', params['_statType']))  # noqa: E501

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'hostExtId', '_startTime', '_endTime', '_samplingInterval', '_statType'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/stats/clusters/{clusterExtId}/hosts/{hostExtId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.stats.HostStatsInfoApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/stats/clusters/{clusterExtId}/hosts/{hostExtId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.stats.HostStatsInfoApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_hosts(self, extId, _page=None, _limit=None, _filter=None, _orderby=None, _apply=None, _select=None, **kwargs):  # noqa: E501
        """Get host entities of a cluster

        >>> response = api.get_hosts(extId, (optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _apply, (optional) _select)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_hosts(extId, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
        :type _page:
            :class:`int`
        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
        :type _limit:
            :class:`int`
        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - bootTimeUsecs - cluster/name - cluster/uuid - cpuCapacityHz - cpuFrequencyHz - cpuModel - defaultVhdContainerUuid - defaultVhdLocation - defaultVmContainerUuid - defaultVmLocation - gpuDriverVersion - gpuList - hostName - hypervisor/type - memorySizeBytes - numberOfCpuCores - numberOfCpuSockets - numberOfCpuThreads 
        :type _filter:
            :class:`str`
        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - cluster/name - controllerVm/externalAddress/ipv4/value - controllerVm/externalAddress/ipv6/value - hostName - hostType - hypervisor/type - memorySizeBytes 
        :type _orderby:
            :class:`str`
        :param _apply: A URL query parameter that allows clients to specify a sequence of transformations to the entity set, such as groupby, filter, aggregate etc. As of now only support for groupby exists.For example '$apply=groupby((templateName))' would get all templates grouped by templateName. The groupby can be applied on the following fields: - cluster/name - hypervisor/type 
        :type _apply:
            :class:`str`
        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. - blockModel - blockSerial - bootTimeUsecs - cluster - cpuCapacityHz - cpuFrequencyHz - cpuModel - defaultVhdContainerUuid - defaultVhdLocation - defaultVmContainerUuid - defaultVmLocation - failoverClusterFqdn - failoverClusterNodeStatus - gpuDriverVersion - gpuList - hostName - hostType - maintenanceState - memorySizeBytes - nodeStatus - numberOfCpuCores - numberOfCpuSockets - numberOfCpuThreads - rebootPending 
        :type _select:
            :class:`str`
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetHostsResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_hosts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []
        if '_page' in params and params['_page'] is not None:
            query_params.append(('$page', params['_page']))  # noqa: E501
        if '_limit' in params and params['_limit'] is not None:
            query_params.append(('$limit', params['_limit']))  # noqa: E501
        if '_filter' in params and params['_filter'] is not None:
            query_params.append(('$filter', params['_filter']))  # noqa: E501
        if '_orderby' in params and params['_orderby'] is not None:
            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
        if '_apply' in params and params['_apply'] is not None:
            query_params.append(('$apply', params['_apply']))  # noqa: E501
        if '_select' in params and params['_select'] is not None:
            query_params.append(('$select', params['_select']))  # noqa: E501

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', '_page', '_limit', '_filter', '_orderby', '_apply', '_select'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/hosts', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetHostsResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/hosts', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetHostsResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_rackable_unit(self, clusterExtId, extId, **kwargs):  # noqa: E501
        """Get rackable unit entity

        >>> response = api.get_rackable_unit(clusterExtId, extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_rackable_unit(clusterExtId, extId, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param extId: Rackable unit UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetRackableUnitResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `get_rackable_unit`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_rackable_unit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/rackable-units/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetRackableUnitResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/rackable-units/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetRackableUnitResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_rackable_units(self, extId, **kwargs):  # noqa: E501
        """Get rackable unit entities of a cluster

        >>> response = api.get_rackable_units(extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_rackable_units(extId, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetRackableUnitsResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_rackable_units`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/rackable-units', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetRackableUnitsResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/rackable-units', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetRackableUnitsResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_rsyslog_server(self, clusterExtId, extId, **kwargs):  # noqa: E501
        """Get RSYSLOG server configuration

        >>> response = api.get_rsyslog_server(clusterExtId, extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_rsyslog_server(clusterExtId, extId, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param extId: RSYSLOG server UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetRsyslogServerResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `get_rsyslog_server`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_rsyslog_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/rsyslog-servers/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetRsyslogServerResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/rsyslog-servers/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetRsyslogServerResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_rsyslog_servers(self, extId, **kwargs):  # noqa: E501
        """Get RSYSLOG servers configuration details

        >>> response = api.get_rsyslog_servers(extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_rsyslog_servers(extId, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetRsyslogServersResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_rsyslog_servers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/rsyslog-servers', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetRsyslogServersResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/rsyslog-servers', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetRsyslogServersResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_snmp(self, extId, **kwargs):  # noqa: E501
        """Get SNMP information

        >>> response = api.get_snmp(extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_snmp(extId, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetSnmpResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_snmp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/snmp', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetSnmpResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/snmp', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetSnmpResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_snmp_trap(self, clusterExtId, extId, **kwargs):  # noqa: E501
        """Get SNMP trap configuration

        >>> response = api.get_snmp_trap(clusterExtId, extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_snmp_trap(clusterExtId, extId, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param extId: SNMP trap UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetSnmpTrapResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `get_snmp_trap`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_snmp_trap`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/snmp/traps/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetSnmpTrapResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/snmp/traps/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetSnmpTrapResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_snmp_user(self, clusterExtId, extId, **kwargs):  # noqa: E501
        """Get SNMP user configuration

        >>> response = api.get_snmp_user(clusterExtId, extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_snmp_user(clusterExtId, extId, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param extId: SNMP user UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetSnmpUserResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `get_snmp_user`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_snmp_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/snmp/users/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetSnmpUserResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/snmp/users/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetSnmpUserResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_virtual_nic(self, clusterExtId, hostExtId, extId, **kwargs):  # noqa: E501
        """Get virtual NIC

        >>> response = api.get_virtual_nic(clusterExtId, hostExtId, extId)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_virtual_nic(clusterExtId, hostExtId, extId, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param hostExtId: Host UUID
        :type hostExtId:
            :class:`str`, required
        :param extId: Virtual NIC UUID
        :type extId:
            :class:`str`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetVirtualNicResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `get_virtual_nic`")  # noqa: E501
        # verify the required parameter 'hostExtId' is set
        if ('hostExtId' not in params or params['hostExtId'] is None):
            raise ValueError("Missing the required parameter `hostExtId` when calling `get_virtual_nic`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_virtual_nic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'hostExtId' in params and params['hostExtId'] is not None:
            path_params['hostExtId'] = params['hostExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'hostExtId', 'extId'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/hosts/{hostExtId}/virtual-nics/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetVirtualNicResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/hosts/{hostExtId}/virtual-nics/{extId}', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetVirtualNicResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def get_virtual_nics(self, clusterExtId, extId, _page=None, _limit=None, _filter=None, _orderby=None, _select=None, **kwargs):  # noqa: E501
        """Get virtual NICs

        >>> response = api.get_virtual_nics(clusterExtId, extId, (optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.get_virtual_nics(clusterExtId, extId, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param extId: Host UUID
        :type extId:
            :class:`str`, required
        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
        :type _page:
            :class:`int`
        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
        :type _limit:
            :class:`int`
        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - dhcpEnabled - interfaceStatus - linkSpeedInKbps - macAddress - mtuInBytes - name - nodeUuid - vlanId 
        :type _filter:
            :class:`str`
        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - name 
        :type _orderby:
            :class:`str`
        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. - dhcpEnabled - hostDescription - interfaceStatus - linkSpeedInKbps - macAddress - mtuInBytes - name - nodeUuid - vlanId 
        :type _select:
            :class:`str`
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetVirtualNicsResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `get_virtual_nics`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `get_virtual_nics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []
        if '_page' in params and params['_page'] is not None:
            query_params.append(('$page', params['_page']))  # noqa: E501
        if '_limit' in params and params['_limit'] is not None:
            query_params.append(('$limit', params['_limit']))  # noqa: E501
        if '_filter' in params and params['_filter'] is not None:
            query_params.append(('$filter', params['_filter']))  # noqa: E501
        if '_orderby' in params and params['_orderby'] is not None:
            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
        if '_select' in params and params['_select'] is not None:
            query_params.append(('$select', params['_select']))  # noqa: E501

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'extId', '_page', '_limit', '_filter', '_orderby', '_select'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/hosts/{extId}/virtual-nics', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetVirtualNicsResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/hosts/{extId}/virtual-nics', 'GET',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetVirtualNicsResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def is_hypervisor_upload_required(self, extId, body, **kwargs):  # noqa: E501
        """Get hypervisor ISO upload information

        >>> response = api.is_hypervisor_upload_required(extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.is_hypervisor_upload_required(extId, body, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param body: Parameters to get information on whether hypervisor ISO upload is required or not
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.HypervisorUploadParam`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.HypervisorUplpadRequiredTaskResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `is_hypervisor_upload_required`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `is_hypervisor_upload_required`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/$actions/check-hypervisor-requirements', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.HypervisorUplpadRequiredTaskResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/$actions/check-hypervisor-requirements', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.HypervisorUplpadRequiredTaskResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def nodes_networking_details(self, extId, body, **kwargs):  # noqa: E501
        """Get network information of unconfigured nodes

        >>> response = api.nodes_networking_details(extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.nodes_networking_details(extId, body, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param body: Node specific details required to fetch node networking information
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.NodeDetails`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetNodeNetworkingTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `nodes_networking_details`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `nodes_networking_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/$actions/fetch-node-networking-details', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetNodeNetworkingTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/$actions/fetch-node-networking-details', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetNodeNetworkingTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def remove_node(self, extId, body, **kwargs):  # noqa: E501
        """Removes nodes from cluster

        >>> response = api.remove_node(extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.remove_node(extId, body, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param body: Parameters to remove nodes from cluster
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.NodeRemovalParams`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.RemoveNodeTaskResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `remove_node`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `remove_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/$actions/remove-node', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.RemoveNodeTaskResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/$actions/remove-node', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.RemoveNodeTaskResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def remove_snmp_transport(self, extId, body, **kwargs):  # noqa: E501
        """Remove SNMP transports

        >>> response = api.remove_snmp_transport(extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.remove_snmp_transport(extId, body, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param body: SNMP transports to remove
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.SnmpTransport`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.RemoveSnmpTransportsTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `remove_snmp_transport`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `remove_snmp_transport`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/snmp/$actions/remove-transports', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.RemoveSnmpTransportsTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/snmp/$actions/remove-transports', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.RemoveSnmpTransportsTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def search_task(self, extId, body, **kwargs):  # noqa: E501
        """Get task response based on the type of request

        >>> response = api.search_task(extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.search_task(extId, body, async_req=True)
        >>> result = thread.get()

        :param extId: The external identifier of the task.
        :type extId:
            :class:`str`, required
        :param body: Search parameters
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.SearchParams`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.GetSearchResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `search_task`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `search_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/tasks/{extId}/$actions/fetch-task-response', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetSearchResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/tasks/{extId}/$actions/fetch-task-response', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.GetSearchResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def update_cluster(self, extId, body, **kwargs):  # noqa: E501
        """Update cluster

        >>> response = api.update_cluster(extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.update_cluster(extId, body, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param body: Cluster resource to update
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.Cluster`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.UpdateClusterTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `update_cluster`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}', 'PUT',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.UpdateClusterTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}', 'PUT',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.UpdateClusterTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def update_rsyslog_server(self, clusterExtId, extId, body, **kwargs):  # noqa: E501
        """Update RSYSLOG server configuration

        >>> response = api.update_rsyslog_server(clusterExtId, extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.update_rsyslog_server(clusterExtId, extId, body, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param extId: RSYSLOG server UUID
        :type extId:
            :class:`str`, required
        :param body: RSYSLOG server to update
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.RsyslogServer`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.UpdateRsyslogServerTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `update_rsyslog_server`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `update_rsyslog_server`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_rsyslog_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/rsyslog-servers/{extId}', 'PUT',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.UpdateRsyslogServerTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/rsyslog-servers/{extId}', 'PUT',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.UpdateRsyslogServerTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def update_snmp_status(self, extId, body, **kwargs):  # noqa: E501
        """Update SNMP status

        >>> response = api.update_snmp_status(extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.update_snmp_status(extId, body, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param body: SNMP status
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.SnmpStatusParam`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.UpdateSnmpStatusTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `update_snmp_status`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_snmp_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/snmp/$actions/update-status', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.UpdateSnmpStatusTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/snmp/$actions/update-status', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.UpdateSnmpStatusTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def update_snmp_trap(self, clusterExtId, extId, body, **kwargs):  # noqa: E501
        """Update SNMP trap

        >>> response = api.update_snmp_trap(clusterExtId, extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.update_snmp_trap(clusterExtId, extId, body, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param extId: SNMP trap UUID
        :type extId:
            :class:`str`, required
        :param body: SNMP trap to update
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.SnmpTrap`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.UpdateSnmpTrapTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `update_snmp_trap`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `update_snmp_trap`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_snmp_trap`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/snmp/traps/{extId}', 'PUT',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.UpdateSnmpTrapTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/snmp/traps/{extId}', 'PUT',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.UpdateSnmpTrapTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def update_snmp_user(self, clusterExtId, extId, body, **kwargs):  # noqa: E501
        """Update SNMP user

        >>> response = api.update_snmp_user(clusterExtId, extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.update_snmp_user(clusterExtId, extId, body, async_req=True)
        >>> result = thread.get()

        :param clusterExtId: Cluster UUID
        :type clusterExtId:
            :class:`str`, required
        :param extId: SNMP user UUID
        :type extId:
            :class:`str`, required
        :param body: SNMP user to update
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.SnmpUser`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.UpdateSnmpUserTaskApiResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'clusterExtId' is set
        if ('clusterExtId' not in params or params['clusterExtId'] is None):
            raise ValueError("Missing the required parameter `clusterExtId` when calling `update_snmp_user`")  # noqa: E501
        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `update_snmp_user`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_snmp_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'clusterExtId' in params and params['clusterExtId'] is not None:
            path_params['clusterExtId'] = params['clusterExtId']  # noqa: E501
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['clusterExtId', 'extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/snmp/users/{extId}', 'PUT',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.UpdateSnmpUserTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{clusterExtId}/snmp/users/{extId}', 'PUT',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.UpdateSnmpUserTaskApiResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data

    def validate_node(self, extId, body, **kwargs):  # noqa: E501
        """Validates hypervisor bundle and node uplinks

        >>> response = api.validate_node(extId, body)

        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.

        >>> thread = api.validate_node(extId, body, async_req=True)
        >>> result = thread.get()

        :param extId: Cluster UUID
        :type extId:
            :class:`str`, required
        :param body: Request body for node validation. It can be OneOf between hypervisor bundle and node uplinks
        :type body:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.ValidateNodeParam`, required
        :param kwargs: kwargs for the method.
                       The following can be passed for an asynchronous HTTP call::

                           async_req=True
        :return: An instance of class :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.ValidateNodeTaskResponse`.

                 If the method is called asynchronously, returns the request thread.
        """ # noqa: E501
        kwargs['_return_http_data_only'] = True

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            params[key] = val
        del params['kwargs']
        del params['self']

        # verify the required parameter 'extId' is set
        if ('extId' not in params or params['extId'] is None):
            raise ValueError("Missing the required parameter `extId` when calling `validate_node`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `validate_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extId' in params and params['extId'] is not None:
            path_params['extId'] = params['extId']  # noqa: E501

        query_params = []

        header_params = {}
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client._select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Process operation specific headers
        extra_params = []
        extra_params.append('async_req')
        extra_params.append('_return_http_data_only')
        extra_params.append('_preload_content')
        extra_params.append('_request_timeout')
        all_params = set(['extId', 'body'])
        all_params.update(extra_params)
        for key, val in six.iteritems(params):
            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                if key.lower() == 'if_match'.lower():
                    key = 'If-Match'
                elif key.lower() == 'if_none_match'.lower():
                    key = 'If-None-Match'
                header_params[key] = val

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params and params['body'] is not None:
            body_params = params['body']

        # Authentication setting
        auth_settings = ['basicAuthScheme']  # noqa: E501

        if kwargs.get('async_req'):
            return self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/$actions/validate-node', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.ValidateNodeTaskResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
        else:
            (data) = self.api_client._call_api(
                '/api/clustermgmt/v4.0.b1/config/clusters/{extId}/$actions/validate-node', 'POST',
                path_params,
                query_params,
                header_params,
                body=body_params,
                post_params=form_params,
                files=local_var_files,
                response_type='clustermgmt.v4.config.ValidateNodeTaskResponse',  # noqa: E501
                auth_settings=auth_settings,
                async_req=params.get('async_req'),
                _return_http_data_only=params.get('_return_http_data_only'),
                _preload_content=params.get('_preload_content', True),
                _request_timeout=params.get('_request_timeout'),
                collection_formats=collection_formats)
            return data
