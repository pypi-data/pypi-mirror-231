# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/svg.ipynb.

# %% auto 0
__all__ = ['Svg']

# %% ../nbs/svg.ipynb 2
import numpy as np
from xml.dom.minidom import parseString
from svg.path import parse_path
import svgwrite
import cv2
import math
import json

# %% ../nbs/svg.ipynb 3
class Svg:
    """
    A class to represent a rectangle and its operations in the context of SVG manipulation.
    """

    def __init__(self):
        """
        Creates a new rectangle instance.
        """
        pass

    def extract_points_from_svg(self, svg_content):
        """
        Extract points from the SVG content.
        
        Parameters:
            svg_content (str): A string containing SVG data.

        Returns:
            np.array: A numpy array containing points extracted from the SVG.
        """
        doc = parseString(svg_content)
        path_strings = [path.getAttribute('d') for path in doc.getElementsByTagName('path')]
        points = []
        num_points_on_curve = 100
        for path_string in path_strings:
            path = parse_path(path_string)
            for e in path:
                if e.__class__.__name__ in ['Line', 'Move']:
                    points.append([e.start.real, e.start.imag])
                    points.append([e.end.real, e.end.imag])
                elif e.__class__.__name__ == 'CubicBezier':
                    t_values = np.linspace(0, 1, num_points_on_curve)
                    for t in t_values:
                        point = e.point(t)
                        points.append([point.real, point.imag])
                # Add more cases for other types of commands if needed
        return np.array(points, dtype=np.float32)
    
    def remove_consecutive_duplicates(self, points_array):
        if len(points_array) < 2:
            return points_array

        new_points = [points_array[0]]

        for i in range(1, len(points_array)):
            if not np.all(points_array[i] == points_array[i - 1]):
                new_points.append(points_array[i])

        return np.array(new_points)

    def compute_minimum_area_rectangle(self, points):

        """
        Compute the minimum area rectangle for a given set of points.
        
        Parameters:
            points (np.array): A numpy array containing points to compute the rectangle for.

        Returns:
            tuple: A tuple containing center, angle, width and height of the rectangle.
        """

        points = self.remove_consecutive_duplicates(points)

        center, (width, height), angle = self.get_aligned_rect(points)

        return center, angle, width, height
    
    def get_average_direction(self, points):
        # パスの前半部分の点を取得
        half_length = len(points) // 2
        first_half = points[:half_length]
        
        total_delta_x = 0
        total_delta_y = 0
        
        # 前半部分の各点間のベクトルを計算
        for i in range(1, len(first_half)):
            delta_x = first_half[i][0] - first_half[i - 1][0]
            delta_y = first_half[i][1] - first_half[i - 1][1]
            total_delta_x += delta_x
            total_delta_y += delta_y
        
        # ベクトルの平均方向を計算
        angle_rad = math.atan2(total_delta_y, total_delta_x)
        
        # ラジアンを度に変換
        angle_deg = math.degrees(angle_rad)
        
        # [0, 180)の範囲に正規化
        if angle_deg < 0:
            angle_deg += 180

        return angle_deg
    
    def get_aligned_rect(self, points):
        # 文字列の平均方向を取得
        average_direction = self.get_average_direction(points)

        # 最小矩形を取得
        rect = cv2.minAreaRect(points)
        center, (width, height), angle = rect

        # 幅と高さの方向が平均方向と逆であれば、入れ替える
        if abs(angle - average_direction) > 45: 
            width, height = height, width
            angle += 90
            angle %= 180

        return center, (width, height), angle

    def create_svg_with_rectangle(self, center, angle, width, height):
        """
        Create an SVG with a rectangle with given center, angle, width and height.
        
        Parameters:
            center (tuple): A tuple representing center of the rectangle.
            angle (float): Angle of rotation of the rectangle.
            width (float): Width of the rectangle.
            height (float): Height of the rectangle.

        Returns:
            svgwrite.drawing.Drawing: An SVG drawing with a rectangle.
        """
        dwg = svgwrite.Drawing(profile='tiny')
        
        # angle_rad = -angle * np.pi / 180.0  # -angle to match SVG rotation direction

        angle_rad = angle * np.pi / 180.0  # -angle to match SVG rotation direction

        rotation_matrix = np.array([
            [np.cos(angle_rad), -np.sin(angle_rad)],
            [np.sin(angle_rad), np.cos(angle_rad)]
        ])
        rect_points = np.array([
            [-width / 2, -height / 2],
            [width / 2, -height / 2],
            [width / 2, height / 2],
            [-width / 2, height / 2]
        ])
        rotated_points = (rotation_matrix @ rect_points.T).T + center
        path = dwg.path(d=f"M {rotated_points[0][0]} {rotated_points[0][1]} ", fill='none', stroke='black')
        for point in rotated_points[1:]:
            path.push(f"L {point[0]} {point[1]} ")
        path.push("Z")  # Close the path
        dwg.add(path)

        return dwg

    def convert_from_svg_str(self, svg):
        """
        Convert SVG string to an SVG string with a minimum area rectangle.
        
        Parameters:
            svg (str): An SVG string to convert.

        Returns:
            str: An SVG string with a minimum area rectangle.
        """
        points = self.extract_points_from_svg(svg)
        center, angle, width, height = self.compute_minimum_area_rectangle(points)
        svg_content = self.create_svg_with_rectangle(center, angle, width, height)
        return svg_content.tostring()

    def convert(self, path, opath):
        """
        Convert SVG content from JSON file to SVG content with minimum area rectangle.
        
        Parameters:
            path (str): The path to the input JSON file.
            opath (str): The path to the output JSON file.

        Returns:
            None
        """
        with open(path, 'r') as f:
            manifest_data = json.load(f)
        canvases = manifest_data['items']
        for canvas in canvases:
            annotations = canvas["annotations"][0]["items"]
            for annotation in annotations:
                target = annotation["target"]
                if "selector" in target and target["selector"]["type"] == "SvgSelector":
                    value = target["selector"]["value"]
                    

                    # text = annotation["body"]["value"]

                    points = self.extract_points_from_svg(value)

                    center, angle, width, height = self.compute_minimum_area_rectangle(points)

                    svg_content2 = self.create_svg_with_rectangle(center, angle, width, height)
                    target["selector"]["value"] = svg_content2.tostring()
        with open(opath, 'w') as f:
            json.dump(manifest_data, f, indent=2)
