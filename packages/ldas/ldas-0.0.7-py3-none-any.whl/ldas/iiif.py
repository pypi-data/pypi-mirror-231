# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/iiif.ipynb.

# %% auto 0
__all__ = ['IIIF_CONTEXT', 'JPEG_FORMAT', 'ORIGIN', 'IIIF']

# %% ../nbs/iiif.ipynb 4
import json
import glob
import os
from PIL import Image
from bs4 import BeautifulSoup
import datetime
from xsd_validator import XsdValidator
import requests
import xml.etree.ElementTree as ET
from typing import List, Dict, Union
from tqdm import tqdm
import os, zipfile

# %% ../nbs/iiif.ipynb 5
IIIF_CONTEXT = "http://iiif.io/api/presentation/3/context.json"
JPEG_FORMAT = "image/jpeg"

ORIGIN = "http://localhost"

class IIIF:

    """
    A class representing the International Image Interoperability Framework (IIIF) for images.
    """

    @staticmethod
    def create_iiif_manifest_from_local_dir(root_path: str, target_path: str, output_path: str, item_id: str, services: str = None) -> None:
        """
        Create an IIIF manifest from a local directory containing .jpg images.

        Args:
            root_path (str): The root path of the images.
            target_path (str): The target path containing the images.
            output_path (str): The path to save the manifest file.
            item_id (str): The ID for the IIIF item.
            services (str): URI for the IIIF manifest.

        Returns:
            None
        """

        prefix_url = f"{ORIGIN}/iiif/{item_id}"
        image_files = IIIF._retrieve_image_files(target_path)
        canvases = IIIF._generate_canvases(image_files, root_path, item_id, prefix_url, services=services)
        manifest = IIIF._generate_manifest(canvases, item_id, prefix_url)
        IIIF._write_manifest_to_file(manifest, output_path)

    @staticmethod
    def _retrieve_image_files(target_path: str) -> List[str]:
        """Retrieve image files from the target path.

        Args:
            target_path (str): The path containing the images.

        Returns:
            list: Sorted list of image file paths.
        """
        return sorted(glob.glob(os.path.join(target_path, "**/*.jpg")))

    @staticmethod
    def _generate_canvases(image_files: List[str], root_path: str, item_id: str, prefix_url: str, services: str = None) -> List[Dict[str, any]]:
        """
        Generate IIIF canvases from image files.

        Args:
            image_files (list): List of image file paths.
            root_path (str): The root path of the images.
            item_id (str): The ID for the IIIF item.
            prefix_url (str): The prefix URL for the IIIF item.
            services (str): URI for the IIIF manifest.

        Returns:
            list: List of IIIF canvases.
        """
        canvases = []

        '''
        if services is not None:
            df = requests.get(services).json()
            context = df["@context"]
            if context == "http://iiif.io/api/presentation/2/context.json":
                canvases = df["sequences"][0]["canvases"]
        '''

        for idx, file_path in enumerate(image_files):
            with Image.open(file_path) as img:
                width, height = img.size

            body = {
                "id": file_path.replace(root_path, ""),
                "type": "Image",
                "format": JPEG_FORMAT,
                "height": height,
                "width": width
            }

            if services is not None:
                body["service"] = services[idx]

            count = idx + 1
            canvas = {
                "id": f"{prefix_url}/canvas/p{count}",
                "type": "Canvas",
                "height": height,
                "width": width,
                "items": [
                    {
                        "type": "AnnotationPage",
                        "items": [
                            {
                                "id": f"{prefix_url}/annotation/p{str(count).zfill(4)}-image",
                                "type": "Annotation",
                                "motivation": "painting",
                                "body": body,
                                "target": f"{prefix_url}/canvas/p{count}"
                            }
                        ]
                    }
                ]
            }
            canvases.append(canvas)

        return canvases

    @staticmethod
    def _generate_manifest(canvases: List[Dict[str, any]], item_id: str, prefix_url: str) -> Dict[str, any]:
        """
        Generate IIIF manifest.

        Args:
            canvases (list): List of IIIF canvases.
            item_id (str): The ID for the IIIF item.

        Returns:
            dict: IIIF manifest dictionary.
        """
        return {
            "@context": IIIF_CONTEXT,
            "id": f"{prefix_url}/manifest.json",
            "type": "Manifest",
            "label": item_id,
            "items": canvases
        }

    @staticmethod
    def _write_manifest_to_file(manifest: Dict[str, any], output_path: str) -> None:
        """
        Write the IIIF manifest to a file.

        Args:
            manifest (dict): IIIF manifest dictionary.
            output_path (str): The path to save the manifest file.
        """
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, "w") as file:
            json.dump(manifest, file, ensure_ascii=False, indent=4)

    @staticmethod
    def points_to_svg_path(points: str) -> str:
        """
        Convert a list of points into an SVG path.

        Args:
            points: String of comma-separated coordinates.

        Returns:
            SVG path representation.
        """
        coordinates = [int(i) for i in points.split(",")]
        path = f"M {coordinates[0]} {coordinates[1]}"
        for i in range(2, len(coordinates), 2):
            path += f" L {coordinates[i]} {coordinates[i+1]}"
        path += " Z"
        return path

    @staticmethod
    def convert_ndl_ocr_xml_to_iiif_manifest(xml_path: str, base_manifest_path: str, output_manifest_path: str) -> None:
        """
        Convert NDL OCR XML to IIIF manifest.

        Args:
            xml_path: Path to the NDL OCR XML file.
            base_manifest_path: Path to the base IIIF manifest.
            output_manifest_path: Path to save the converted IIIF manifest.

        """
        with open(base_manifest_path) as f:
            manifest_base = json.load(f)

        canvases = manifest_base["items"]        

        # Load XML content
        with open(xml_path, "r") as file:
            content = file.read()

        # Create a BeautifulSoup object
        soup = BeautifulSoup(content, "lxml")

        xml_pages = soup.find_all("page")

        stored_annotations: List[List[Dict[str, Union[str, Dict[str, any]]]]] = []

        for i, xml_page in enumerate(xml_pages):
            canvas_id = canvases[i]["id"]
            annotationPageItems = []

            for xml_block in xml_page.find_all("block"):
                annotationPageItems.append(IIIF._process_block(xml_block, canvas_id, len(annotationPageItems)))

            for xml_line in xml_page.find_all("line"):
                annotationPageItems.append(IIIF._process_line(xml_line, canvas_id, len(annotationPageItems)))

            for xml_polygon in xml_page.find_all("polygon"):
                annotationPageItems.append(IIIF._process_polygon(xml_polygon, canvas_id, len(annotationPageItems)))

            stored_annotations.append(annotationPageItems)

        for i, canvas in enumerate(canvases):

            annotationPageItems = stored_annotations[i]

            canvas["annotations"] = [
                {
                    "type": "AnnotationPage",
                    "items": annotationPageItems
                }
            ]

        with open(output_manifest_path, "w") as f:
            json.dump(manifest_base, f, indent=4, ensure_ascii=False)

    @staticmethod
    def get_color(type_: str) -> str:
        color = "black"

        if type_ == "ルビ":
            color = "blue"
        elif type_ == "頭注":
            color = "brown"
        elif type_ == "本文":
            color = "red"
        elif type_ == "割注":
            color = "green"

        return color

    @staticmethod
    def _process_block(xml_block, canvas_id: str, index: int) -> Dict[str, any]:
        """
        Process XML block and return the corresponding annotation.

        Args:
            xml_block: The block element from the XML.
            canvas_id: The canvas ID for the current page.

        Returns:
            An annotation dictionary for the given block.
        """
        # TODO: Implement this using the block processing logic from above
        x = xml_block["x"]
        y = xml_block["y"]
        w = xml_block["width"]
        h = xml_block["height"]

        x = int(x)
        y = int(y)
        w = int(w)
        h = int(h)

        string = xml_block["string"] if "string" in xml_block.attrs else ""

        points = f"{x},{y},{x+w},{y},{x+w},{y+h},{x},{y+h}"
        p = IIIF.points_to_svg_path(points)

        block_type = xml_block["type"]

        color = IIIF.get_color(block_type)

        return {
                "id": f"a_{index}_{x}_{y}_{w}_{h}",
                "type": "Annotation",
                "_motivation": "tagging",
                "motivation": "commenting",
                "body": {
                    "type": "TextualBody",
                    "value": f'【{block_type}】{string}'

                },
                "target2": f"{canvas_id}#xywh={x},{y},{w},{h}",
                "target": {
                            "type": "SpecificResource",
                            "source": canvas_id,
                            "selector": {
                                "type": "SvgSelector",
                                "value": f"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'><g><path d='{p}' stroke=\"{color}\" /></g></svg>"
                            }
                        }
            }
        

    @staticmethod
    def _process_line(xml_line, canvas_id: str, index: int) -> Dict[str, any]:
        """
        Process XML line and return the corresponding annotation.

        Args:
            xml_line: The line element from the XML.
            canvas_id: The canvas ID for the current page.

        Returns:
            An annotation dictionary for the given line.
        """
        # TODO: Implement this using the line processing logic from above
        x = xml_line["x"]
        y = xml_line["y"]
        w = xml_line["width"]
        h = xml_line["height"]

        order = xml_line["order"] if "order" in xml_line.attrs else "-1"

        string = xml_line["string"] if "string" in xml_line.attrs else ""

        block_type = xml_line["type"]

        color = IIIF.get_color(block_type)

        x = int(x)
        y = int(y)
        w = int(w)
        h = int(h)

        points = f"{x},{y},{x+w},{y},{x+w},{y+h},{x},{y+h}"
        p = IIIF.points_to_svg_path(points)

        return {
                "id": f"a_{index}_{x}_{y}_{w}_{h}",
                "type": "Annotation",
                "_motivation": "tagging",
                "motivation": "commenting",
                "body": {
                    "type": "TextualBody",
                    "value": f'【{block_type}:{order}】{string}'

                },
                "target2": f"{canvas_id}#xywh={x},{y},{w},{h}",
                "target": {
                            "type": "SpecificResource",
                            "source": canvas_id,
                            "selector": {
                                "type": "SvgSelector",
                                "value": f"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'><g><path d='{p}' stroke=\"{color}\" /></g></svg>"
                            }
                        }
            }

    @staticmethod
    def _process_polygon(xml_polygon, canvas_id: str, index: int) -> Dict[str, any]:
        """
        Process XML polygon and return the corresponding annotation.

        Args:
            xml_polygon: The polygon element from the XML.
            canvas_id: The canvas ID for the current page.

        Returns:
            An annotation dictionary for the given polygon.
        """
        # TODO: Implement this using the polygon processing logic from above
        points = xml_polygon["points"] # .split(",")
        p = IIIF.points_to_svg_path(points)

        return {
                "id": f"a_{index}_{points}",
                "type": "Annotation",
                "motivation": "tagging",
                "body": {
                    "type": "TextualBody",
                    "value": "TEXTBLOCK"

                },
                "target": {
                            "type": "SpecificResource",
                            "source": canvas_id,
                            "selector": {
                                "type": "SvgSelector",
                                "___value": f"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'><g><path d='{p}' stroke='red' fill='none'/></g></svg>",
                                "value": f"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'><g><path d='{p}' fill-opacity=\"0.1\" fill='orange' stroke=\"orange\" stroke-opacity=\"0.5\" stroke-width=\"1\"/></g></svg>"
                            }
                        }
            }

    @staticmethod
    def _create_and_set_tag(soup, tag_name, string_content=None, parent=None):
        """
        Helper function to create a tag, set its content, and optionally attach it to a parent tag.

        Args:
            soup: The BeautifulSoup object used for creating the tag.
            tag_name: The name of the tag to be created.
            string_content: The content to be set inside the tag.
            parent: The tag to which the created tag should be attached.

        Returns:
            The created tag.
        """
        tag = soup.new_tag(tag_name)
        if string_content:
            tag.string = string_content
        if parent:
            parent.append(tag)
        return tag

    @staticmethod
    def set_desc(alto: BeautifulSoup, soup_alto: BeautifulSoup, opt_str: str, filename: str) -> BeautifulSoup:
        """
        Set description details to an ALTO (Analyzed Layout and Text Object) structure.

        Args:
            alto: A BeautifulSoup object representing the ALTO structure to be modified.
            soup_alto: The BeautifulSoup object used to create new tags.
            opt_str: A string representing OCR processing options.
            filename: The name of the source image file.

        Returns:
            The modified BeautifulSoup object representing the updated ALTO structure.
        """
        desc = IIIF._create_and_set_tag(soup_alto, "Description", parent=alto)
        
        IIIF._create_and_set_tag(soup_alto, "MeasurementUnit", "pixel", desc)

        source_img_info = IIIF._create_and_set_tag(soup_alto, "sourceImageInformation", parent=desc)
        IIIF._create_and_set_tag(soup_alto, "fileName", filename, source_img_info)

        ocr_processing = IIIF._create_and_set_tag(soup_alto, "OCRProcessing", parent=desc)
        ocr_processing["ID"] = "OCR_1"

        ocr_processing_step = IIIF._create_and_set_tag(soup_alto, "ocrProcessingStep", parent=ocr_processing)
        
        dt_now = datetime.datetime.now(datetime.timezone(datetime.timedelta(hours=9)))
        IIIF._create_and_set_tag(soup_alto, "processingDateTime", dt_now.isoformat(), ocr_processing_step)
        IIIF._create_and_set_tag(soup_alto, "processingAgency", "Google Colaboratory", ocr_processing_step)
        IIIF._create_and_set_tag(soup_alto, "processingStepSettings", opt_str, ocr_processing_step)

        processing_software = IIIF._create_and_set_tag(soup_alto, "processingSoftware", parent=ocr_processing_step)

        software_details = {
            "softwareCreator": "National Diet Library",
            "softwareName": "NDLOCR",
            "softwareVersion": "2.1"
        }

        for tag, value in software_details.items():
            IIIF._create_and_set_tag(soup_alto, tag, value, processing_software)

        return alto
    
    @staticmethod
    def _pretty_print(current, parent = None, index: int = -1, depth: int = 0) -> None:
        """
        Recursive function to pretty print XML elements with indentation.

        Args:
            current: The current XML element being processed.
            parent: The parent of the current XML element.
            index: The index of the current XML element in its parent's children list.
            depth: Current depth for indentation.
        """
        for i, node in enumerate(current):
            IIIF._pretty_print(node, current, i, depth + 1)
        if parent is not None:
            if index == 0:
                parent.text = '\n' + ('\t' * depth)
            else:
                parent[index - 1].tail = '\n' + ('\t' * depth)
            if index == len(parent) - 1:
                current.tail = '\n' + ('\t' * (depth - 1))

    @staticmethod
    def format_and_save(html: str, output_path: str) -> None:
        """
        Reformat the provided HTML content and save it as an XML file.

        Args:
            html: HTML content to be reformatted.
            output_path: The file path where the reformatted content should be saved.
        """
        root = ET.fromstring(html)
        ET.register_namespace('', 'http://www.loc.gov/standards/alto/ns-v4#')

        IIIF._pretty_print(root)
        tree = ET.ElementTree(root)
        tree.write(output_path, encoding="utf-8", xml_declaration=True)

    @staticmethod
    def validate(output_path: str) -> None:
        """
        Validate the XML file against the ALTO v4.2 schema.

        Args:
            output_path: The file path of the XML to be validated.
        """
        schema_path = "/tmp/url.xml"
        schema_url = "http://www.loc.gov/standards/alto/v4/alto-4-2.xsd"

        if not os.path.exists(schema_path):

            response = requests.get(schema_url)
            with open(schema_path, 'wb') as file:
                file.write(response.content)
        
        try:
            validator = XsdValidator(schema_path)
            validator.assert_valid(output_path)
        except Exception as e:
            print(e)

    @staticmethod
    def convert_ndl_ocr_xml_to_alto_xml(xml_path, output_dir, opt_json_path, is_validate: bool = False):
        """
        Convert NDL OCR XML to ALTO XML format.

        Args:
            xml_path: The file path to the source XML.
            output_dir: The directory where the output ALTO XML files should be saved.
            opt_json_path: The file path to the JSON options file.
        """
        item_id = os.path.basename(xml_path).split(".")[0]

        with open(opt_json_path, "r") as f:
            opt_json = json.load(f)
        
        opt_str = json.dumps(opt_json, ensure_ascii=False)

        # Load XML content
        with open(xml_path, "r") as file:
            content = file.read()

        # Create BeautifulSoup object
        soup = BeautifulSoup(content, "lxml")
        xml_pages = soup.find_all("page")        

        for i, xml_page in enumerate(xml_pages):
            soup_alto = BeautifulSoup(features="xml")
            alto = soup_alto.new_tag("alto", 
                                     xmlns="http://www.loc.gov/standards/alto/ns-v4#", 
                                     **{"xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance", 
                                        "xsi:schemaLocation": "http://www.loc.gov/standards/alto/ns-v4# http://www.loc.gov/standards/alto/v4/alto-4-2.xsd"})
            soup_alto.append(alto)

            filename = f"{str(i + 1).zfill(4)}.xml"
            alto = IIIF.set_desc(alto, soup_alto, opt_str, f"{item_id}_{filename}")
            
            layout = soup_alto.new_tag("Layout")
            alto.append(layout)
            page = soup_alto.new_tag("Page", ID="Page_" + str(i + 1), PHYSICAL_IMG_NR=str(i + 1))
            layout.append(page)

            printSpace = soup_alto.new_tag("PrintSpace", ID="PrintSpace_" + str(i + 1))
            page.append(printSpace)
            
            ex_blocks = []
            ex_lines = []

            def createLine(line, ex_lines):
                textLine = soup_alto.new_tag("TextLine")
                textBlock.append(textLine)
                
                # textLine["CONTENT"] = line["string"]

                ex_lines.append(line)
                textLine["ID"] = "TextLine_" + str(len(ex_lines))

                textLine["HPOS"] = line["x"]
                textLine["VPOS"] = line["y"]
                textLine["WIDTH"] = line["width"]
                textLine["HEIGHT"] = line["height"]

                textString = soup_alto.new_tag("String")
                textLine.append(textString)
                textString["ID"] = "Word_" + str(len(ex_lines))
                textString["CONTENT"] = line["string"]

                textString["HPOS"] = line["x"]
                textString["VPOS"] = line["y"]
                textString["WIDTH"] = line["width"]
                textString["HEIGHT"] = line["height"]

                return textLine


            children = xml_page.findChildren(recursive=False)
            for child in children:
                if child.name == "textblock":

                    textBlock = soup_alto.new_tag("TextBlock")
                    printSpace.append(textBlock)

                    ex_blocks.append(textBlock)

                    textBlock["ID"] = "TextBlock_" + str(len(ex_blocks))

                    lines = child.find_all("line")

                    for line in lines:
                        textLine = createLine(line, ex_lines)
                        textBlock.append(textLine)
                        
                        

                elif child.name == "line":

                    textBlock = soup_alto.new_tag("TextBlock")
                    printSpace.append(textBlock)

                    ex_blocks.append(textBlock)

                    textBlock["ID"] = "TextBlock_" + str(len(ex_blocks))

                    textLine = createLine(child, ex_lines)
                    textBlock.append(textLine)

            output_path = os.path.join(output_dir, filename)
            os.makedirs(os.path.dirname(output_path), exist_ok=True)

            html = str(soup_alto)
            IIIF.format_and_save(html, output_path)

            if is_validate:
                IIIF.validate(output_path)

    @staticmethod
    def create_annolist(manifest3: dict, output_dir: str) -> None:
        """
        Create an annotation list.

        Args:
            manifest3: A dictionary containing the IIIF Presentation API 3.0 manifest data.
            output_dir: The directory where the annotation list JSON files should be saved.
        """
        items = manifest3["items"]

        for i, item in enumerate(items):
            filename = str(i + 1).zfill(4)
            output_path = output_dir + "/" + filename + ".json"

            resources = []

            for annotation in item["annotations"]:
                items = annotation["items"]

                for item in items:

                    target = item["target"]

                    if type (target) is str:
                        on = target
                    else:
                        on = [
                            {
                                "@type": "oa:SpecificResource",
                                "full": target["source"],
                                "selector": {
                                    "@type": "oa:Choice",
                                    "item": {
                                        "@type": "oa:SvgSelector",
                                        "value": target["selector"]["value"]
                                    }
                                }
                            }
                        ] # item["target"]

                    resource = {
                        "@id": item["id"],
                        "@type": "oa:Annotation",
                        "motivation": "sc:painting",
                        "resource": {
                            "@type": "cnt:ContentAsText",
                            "format": "text/plain",
                            "chars": item["body"]["value"]
                        },
                        "on": on
                    }
                    resources.append(resource)

            annolist = {
                "@context": "http://iiif.io/api/presentation/2/context.json",
                "@id": manifest3["id"].replace("/manifest.json", "") + "/canvases/" + filename + ".json",
                "@type": "sc:AnnotationList",
                "resources": resources
            }

            with open(output_path, "w") as f:
                json.dump(annolist, f, ensure_ascii=False, indent=4)


    @staticmethod
    def create_manifest_with_alto(manifest_path: str, output_path: str) -> None:
        """
        Create a manifest using ALTO format annotations.

        Args:
            manifest_path: The file path to the source IIIF Presentation API 3.0 manifest.
            output_path: The file path where the created IIIF Presentation API 2.0 manifest should be saved.
        """

        with open(manifest_path, "r") as f:
            manifest3 = json.load(f)

        IIIF.create_annolist(manifest3, os.path.dirname(manifest_path) + "/canvases")

        canvases2 = []
        canvases3 = manifest3["items"]

        prefix_url = manifest3["id"].replace("/manifest.json", "")

        for i, canvas3 in enumerate(canvases3):

            resource = {
                "@id": canvas3["items"][0]["items"][0]["body"]["id"],
                "@type": "dctypes:Image",
                "format": "image/jpeg",
                "height": canvas3["height"],
                "width": canvas3["width"]
            }

            if "service" in canvas3["items"][0]["items"][0]["body"]:
                resource["service"] = canvas3["items"][0]["items"][0]["body"]["service"]
            
            canvas2 = {
                "@id": canvas3["id"],
                "@type": "sc:Canvas",
                # "label": canvas3["label"],
                "height": canvas3["height"],
                "width": canvas3["width"],
                "images": [
                    {
                        "@type": "oa:Annotation",
                        "motivation": "sc:painting",
                        "on": canvas3["id"],
                        "resource": resource
                    }
                ],
                "otherContent": [
                    {
                        "@id": f"{prefix_url.replace(ORIGIN, '')}/canvases/{str(i + 1).zfill(4)}.json",
                        "@type": "sc:AnnotationList"
                    }
                ],
                "seeAlso": {
                    "@id": f"{prefix_url.replace(ORIGIN, '')}/canvases/{str(i + 1).zfill(4)}.xml",
                    "profile": "http://www.loc.gov/standards/alto/v4/alto.xsd",
                    "format": "text/xml",
                    "label": "METS-ALTO XML"
                }
            }

            canvases2.append(canvas2)

        manifest2 = {
            "@context": "http://iiif.io/api/presentation/2/context.json",
            "@id": manifest3["id"],
            "@type": "sc:Manifest",
            "label": manifest3["label"],
            # "metadata": manifest3["metadata"],
            "sequences": [
                {
                    # "@id": manifest3["sequences"][0]["@id"],
                    "@type": "sc:Sequence",
                    "canvases": canvases2
                }
            ]
        }

        with open(output_path, "w") as f:
            json.dump(manifest2, f, ensure_ascii=False, indent=4,
                    sort_keys=True, separators=(',', ': '))
            
    @staticmethod
    def ndl_ocr_post_process(root_path: str, target_path: str, output_iiif_v3_path: str, item_id: str, xml_path: str, 
                             output_anno_path: str, output_canvases_dir: str, opt_json_path: str, output_manifest_alto_path: str, services: str = None) -> None:
        """
        Process the NDL OCR and generate IIIF manifests and ALTO XMLs.

        Args:
            root_path (str): The root directory.
            target_path (str): Path to the target files.
            output_iiif_v3_path (str): Output path for IIIF v3 manifest.
            item_id (str): Identifier for the item.
            xml_path (str): Path to the input XML.
            output_anno_path (str): Output path for annotations.
            output_canvases_dir (str): Directory for saving the canvases.
            opt_json_path (str): Path to the options JSON.
            output_manifest_alto_path (str): Output path for manifest with ALTO annotations.
            services (str): URI for the IIIF manifest.
        """
        IIIF.create_iiif_manifest_from_local_dir(root_path, target_path, output_iiif_v3_path, item_id, services=services)
        IIIF.convert_ndl_ocr_xml_to_iiif_manifest(xml_path, output_iiif_v3_path, output_anno_path)
        IIIF.convert_ndl_ocr_xml_to_alto_xml(xml_path, output_canvases_dir, opt_json_path)
        IIIF.create_manifest_with_alto(output_anno_path, output_manifest_alto_path)

    @staticmethod
    def ndl_ocr_post_process_simple(root_path: str, output_dir: str, task_id: str, services: str = None) -> None:
        """
        Simplified NDL OCR post-processing. Generates IIIF manifests and ALTO XMLs based on a given task ID.

        Args:
            root_path (str): The root directory.
            output_dir (str): The output directory for the processed data.
            task_id (str): Identifier for the task.
        """
        target_path = f"{root_path}/files/{task_id}"
        base_manifest_path = f"{root_path}/iiif/{task_id}/manifest.json"
        xml_path = f"{output_dir}/{task_id}/xml/{task_id}.xml"
        output_manifest_path = f"{root_path}/iiif/{task_id}/manifest_a.json"
        output_canvases_dir = f"{root_path}/iiif/{task_id}/canvases"
        opt_json_path = f"{output_dir}/opt.json"
        output_manifest_alto_path = f"{root_path}/iiif/{task_id}/manifest_o.json"

        IIIF.ndl_ocr_post_process(root_path, target_path, base_manifest_path, task_id, xml_path, output_manifest_path, output_canvases_dir, opt_json_path, output_manifest_alto_path, services=services)

    @staticmethod
    def download_images_from_manifest(url: str, output_dir: str) -> None:
        df = requests.get(url).json()

        context = df["@context"]

        if "/2/" in context:
            canvases = df["sequences"][0]["canvases"]

            for i in tqdm(range(len(canvases))):
                canvas = canvases[i]
                image_url = canvas["images"][0]["resource"]["@id"]
                image_name = f"{str(i + 1).zfill(4)}.jpg"
                image_path = os.path.join(output_dir, image_name)

                if not os.path.exists(image_path):

                    os.makedirs(os.path.dirname(image_path), exist_ok=True)

                    response = requests.get(image_url)
                    with open(image_path, 'wb') as file:
                        file.write(response.content)

    @staticmethod
    def create_zip(item_id: str, output_dir: str) -> None:
        url = f"https://kokusho.nijl.ac.jp/biblio/{item_id}/manifest"
        output_dir = f"{output_dir}/files/{item_id}/img"
        IIIF.download_images_from_manifest(url, output_dir)

        
        opath = f'{output_dir}/zip/{item_id}.zip'
        os.makedirs(os.path.dirname(opath), exist_ok=True)
        with zipfile.ZipFile(opath,'w') as myzip:
            for f in os.listdir(output_dir):
                myzip.write(os.path.join(output_dir, f), "img/" + f)

    @staticmethod
    def convert_json_to_xml(json_dir, img_dir, output_path): # task_id # output_dir

        # output_task_dir = f"{output_dir}/{task_id}"

        # json_dir = f"{output_task_dir}/json"

        files = glob.glob(img_dir + "/*.jpg")

        files.sort()

        soup = BeautifulSoup("", 'xml')
        ocr = soup.new_tag("OCRDATASET")
        soup.append(ocr)

        for file in files:
            filename = file.split("/")[-1].split(".")[0]

            im = Image.open(file)
            w, h = im.size

            json_path = json_dir + "/" + filename + ".json"
            with open(json_path, "r") as f:
                df = json.load(f)

            # print(df)


            page = soup.new_tag("PAGE",attrs={
                "IMAGENAME": file.split("/")[-1],
                "WIDTH" : w,
                "HEIGHT" : h
                })
            ocr.append(page)

            block = soup.new_tag("TEXTBLOCK ")
            page.append(block)

            bbs = df[0]

            for i in range(len(bbs)):
                e = bbs[i]

                line = soup.new_tag("LINE",attrs={
                "TYPE": "本文",
                "X" : e[0],
                "Y" : e[1],
                "WIDTH": e[2] - e[0],
                "HEIGHT": e[3] - e[1],
                "STRING": e[4],
                "ORDER": i
                })

                block.append(line)

        # xml_path = f"{output_task_dir}/xml/{task_id}.xml"
        xml_path = output_path

        os.makedirs(os.path.dirname(xml_path), exist_ok=True)
        f = open(xml_path, "w")
        f.write(str(soup))
        f.close()
