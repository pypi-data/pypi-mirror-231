"""
This type stub file was generated by pyright.
"""

import asyncio
from typing import Any, Awaitable, Dict, Generator, List, Optional, Union
from pyee import EventEmitter
from pyppeteer.connection import CDPSession
from pyppeteer.element_handle import ElementHandle
from pyppeteer.execution_context import ExecutionContext, JSHandle

"""Frame Manager module."""
logger = ...
class FrameManager(EventEmitter):
    """FrameManager class."""
    Events = ...
    def __init__(self, client: CDPSession, frameTree: Dict, page: Any) -> None:
        """Make new frame manager."""
        ...
    
    @property
    def mainFrame(self) -> Optional[Frame]:
        """Return main frame."""
        ...
    
    def frames(self) -> List[Frame]:
        """Return all frames."""
        ...
    
    def frame(self, frameId: str) -> Optional[Frame]:
        """Return :class:`Frame` of ``frameId``."""
        ...
    
    def executionContextById(self, contextId: str) -> ExecutionContext:
        """Get stored ``ExecutionContext`` by ``id``."""
        ...
    
    def createJSHandle(self, context: ExecutionContext, remoteObject: Dict = ...) -> JSHandle:
        """Create JS handle associated to the context id and remote object."""
        ...
    


class Frame:
    """Frame class.

    Frame objects can be obtained via :attr:`pyppeteer.page.Page.mainFrame`.
    """
    def __init__(self, client: CDPSession, parentFrame: Optional[Frame], frameId: str) -> None:
        ...
    
    async def executionContext(self) -> Optional[ExecutionContext]:
        """Return execution context of this frame.

        Return :class:`~pyppeteer.execution_context.ExecutionContext`
        associated to this frame.
        """
        ...
    
    async def evaluateHandle(self, pageFunction: str, *args: Any) -> JSHandle:
        """Execute function on this frame.

        Details see :meth:`pyppeteer.page.Page.evaluateHandle`.
        """
        ...
    
    async def evaluate(self, pageFunction: str, *args: Any, force_expr: bool = ...) -> Any:
        """Evaluate pageFunction on this frame.

        Details see :meth:`pyppeteer.page.Page.evaluate`.
        """
        ...
    
    async def querySelector(self, selector: str) -> Optional[ElementHandle]:
        """Get element which matches `selector` string.

        Details see :meth:`pyppeteer.page.Page.querySelector`.
        """
        ...
    
    async def xpath(self, expression: str) -> List[ElementHandle]:
        """Evaluate the XPath expression.

        If there are no such elements in this frame, return an empty list.

        :arg str expression: XPath string to be evaluated.
        """
        ...
    
    async def querySelectorEval(self, selector: str, pageFunction: str, *args: Any) -> Any:
        """Execute function on element which matches selector.

        Details see :meth:`pyppeteer.page.Page.querySelectorEval`.
        """
        ...
    
    async def querySelectorAllEval(self, selector: str, pageFunction: str, *args: Any) -> Optional[Dict]:
        """Execute function on all elements which matches selector.

        Details see :meth:`pyppeteer.page.Page.querySelectorAllEval`.
        """
        ...
    
    async def querySelectorAll(self, selector: str) -> List[ElementHandle]:
        """Get all elements which matches `selector`.

        Details see :meth:`pyppeteer.page.Page.querySelectorAll`.
        """
        ...
    
    J = ...
    Jx = ...
    Jeval = ...
    JJ = ...
    JJeval = ...
    async def content(self) -> str:
        """Get the whole HTML contents of the page."""
        ...
    
    async def setContent(self, html: str) -> None:
        """Set content to this page."""
        ...
    
    @property
    def name(self) -> str:
        """Get frame name."""
        ...
    
    @property
    def url(self) -> str:
        """Get url of the frame."""
        ...
    
    @property
    def parentFrame(self) -> Optional[Frame]:
        """Get parent frame.

        If this frame is main frame or detached frame, return ``None``.
        """
        ...
    
    @property
    def childFrames(self) -> List[Frame]:
        """Get child frames."""
        ...
    
    def isDetached(self) -> bool:
        """Return ``True`` if this frame is detached.

        Otherwise return ``False``.
        """
        ...
    
    async def injectFile(self, filePath: str) -> str:
        """[Deprecated] Inject file to the frame."""
        ...
    
    async def addScriptTag(self, options: Dict) -> ElementHandle:
        """Add script tag to this frame.

        Details see :meth:`pyppeteer.page.Page.addScriptTag`.
        """
        ...
    
    async def addStyleTag(self, options: Dict) -> ElementHandle:
        """Add style tag to this frame.

        Details see :meth:`pyppeteer.page.Page.addStyleTag`.
        """
        ...
    
    async def click(self, selector: str, options: Dict[str, Any] = ..., **kwargs: Any) -> None:
        """Click element which matches ``selector``.

        Details see :meth:`pyppeteer.page.Page.click`.
        """
        ...
    
    async def focus(self, selector: str) -> None:
        """Focus element which matches ``selector``.

        Details see :meth:`pyppeteer.page.Page.focus`.
        """
        ...
    
    async def hover(self, selector: str) -> None:
        """Mouse hover the element which matches ``selector``.

        Details see :meth:`pyppeteer.page.Page.hover`.
        """
        ...
    
    async def select(self, selector: str, *values: str) -> List[str]:
        """Select options and return selected values.

        Details see :meth:`pyppeteer.page.Page.select`.
        """
        ...
    
    async def tap(self, selector: str) -> None:
        """Tap the element which matches the ``selector``.

        Details see :meth:`pyppeteer.page.Page.tap`.
        """
        ...
    
    async def type(self, selector: str, text: str, options: Dict[str, Any] = ..., **kwargs: Any) -> None:
        """Type ``text`` on the element which matches ``selector``.

        Details see :meth:`pyppeteer.page.Page.type`.
        """
        ...
    
    def waitFor(self, selectorOrFunctionOrTimeout: Union[str, int, float], options: Dict[str, Any] = ..., *args: Any, **kwargs: Any) -> Union[Awaitable, WaitTask]:
        """Wait until `selectorOrFunctionOrTimeout`.

        Details see :meth:`pyppeteer.page.Page.waitFor`.
        """
        ...
    
    def waitForSelector(self, selector: str, options: Dict[str, Any] = ..., **kwargs: Any) -> WaitTask:
        """Wait until element which matches ``selector`` appears on page.

        Details see :meth:`pyppeteer.page.Page.waitForSelector`.
        """
        ...
    
    def waitForXPath(self, xpath: str, options: Dict[str, Any] = ..., **kwargs: Any) -> WaitTask:
        """Wait until element which matches ``xpath`` appears on page.

        Details see :meth:`pyppeteer.page.Page.waitForXPath`.
        """
        ...
    
    def waitForFunction(self, pageFunction: str, options: Dict[str, Any] = ..., *args: Any, **kwargs: Any) -> WaitTask:
        """Wait until the function completes.

        Details see :meth:`pyppeteer.page.Page.waitForFunction`.
        """
        ...
    
    async def title(self) -> str:
        """Get title of the frame."""
        ...
    


class WaitTask:
    """WaitTask class.

    Instance of this class is awaitable.
    """
    def __init__(self, frame: Frame, predicateBody: str, title: str, polling: Union[str, int], timeout: float, loop: asyncio.AbstractEventLoop, *args: Any) -> None:
        ...
    
    def __await__(self) -> Generator:
        """Make this class **awaitable**."""
        ...
    
    def terminate(self, error: Exception) -> None:
        """Terminate this task."""
        ...
    
    async def rerun(self) -> None:
        """Start polling."""
        ...
    


waitForPredicatePageFunction = ...
