"""
This type stub file was generated by pyright.
"""

import ast
import inspect
from collections.abc import Mapping, Sequence
from types import MethodType
from typing import Any, Callable

"""Helpers for inspecting Python modules."""
logger = ...
memory_address_re = ...
def unwrap(obj: Any) -> Any:
    """Get an original object from wrapped object (wrapped functions)."""
    ...

def unwrap_all(obj: Any, *, stop: Callable | None = ...) -> Any:
    """
    Get an original object from wrapped object (unwrapping partials, wrapped
    functions, and other decorators).
    """
    ...

def getall(obj: Any) -> Sequence[str] | None:
    """Get __all__ attribute of the module as dict.

    Return None if given *obj* does not have __all__.
    Raises ValueError if given *obj* have invalid __all__.
    """
    ...

def getannotations(obj: Any) -> Mapping[str, Any]:
    """Get __annotations__ from given *obj* safely."""
    ...

def getglobals(obj: Any) -> Mapping[str, Any]:
    """Get __globals__ from given *obj* safely."""
    ...

def getmro(obj: Any) -> tuple[type, ...]:
    """Get __mro__ from given *obj* safely."""
    ...

def getorigbases(obj: Any) -> tuple[Any, ...] | None:
    """Get __orig_bases__ from *obj* safely."""
    ...

def getslots(obj: Any) -> dict[str, Any] | None:
    """Get __slots__ attribute of the class as dict.

    Return None if gienv *obj* does not have __slots__.
    Raises TypeError if given *obj* is not a class.
    Raises ValueError if given *obj* have invalid __slots__.
    """
    ...

def isNewType(obj: Any) -> bool:
    """Check the if object is a kind of NewType."""
    ...

def isenumclass(x: Any) -> bool:
    """Check if the object is subclass of enum."""
    ...

def isenumattribute(x: Any) -> bool:
    """Check if the object is attribute of enum."""
    ...

def unpartial(obj: Any) -> Any:
    """Get an original object from partial object.

    This returns given object itself if not partial.
    """
    ...

def ispartial(obj: Any) -> bool:
    """Check if the object is partial."""
    ...

def isclassmethod(obj: Any, cls: Any = ..., name: str | None = ...) -> bool:
    """Check if the object is classmethod."""
    ...

def isstaticmethod(obj: Any, cls: Any = ..., name: str | None = ...) -> bool:
    """Check if the object is staticmethod."""
    ...

def isdescriptor(x: Any) -> bool:
    """Check if the object is some kind of descriptor."""
    ...

def isabstractmethod(obj: Any) -> bool:
    """Check if the object is an abstractmethod."""
    ...

def isboundmethod(method: MethodType) -> bool:
    """Check if the method is a bound method."""
    ...

def is_cython_function_or_method(obj: Any) -> bool:
    """Check if the object is a function or method in cython."""
    ...

def isattributedescriptor(obj: Any) -> bool:
    """Check if the object is an attribute like descriptor."""
    ...

def is_singledispatch_function(obj: Any) -> bool:
    """Check if the object is singledispatch function."""
    ...

def is_singledispatch_method(obj: Any) -> bool:
    """Check if the object is singledispatch method."""
    ...

def isfunction(obj: Any) -> bool:
    """Check if the object is function."""
    ...

def isbuiltin(obj: Any) -> bool:
    """Check if the object is function."""
    ...

def isroutine(obj: Any) -> bool:
    """Check is any kind of function or method."""
    ...

def iscoroutinefunction(obj: Any) -> bool:
    """Check if the object is coroutine-function."""
    ...

def isproperty(obj: Any) -> bool:
    """Check if the object is property."""
    ...

def isgenericalias(obj: Any) -> bool:
    """Check if the object is GenericAlias."""
    ...

def safe_getattr(obj: Any, name: str, *defargs: Any) -> Any:
    """A getattr() that turns all exceptions into AttributeErrors."""
    ...

def object_description(obj: Any, *, _seen: frozenset = ...) -> str:
    """A repr() implementation that returns text safe to use in reST context.

    Maintains a set of 'seen' object IDs to detect and avoid infinite recursion.
    """
    ...

def is_builtin_class_method(obj: Any, attr_name: str) -> bool:
    """If attr_name is implemented at builtin class, return True.

        >>> is_builtin_class_method(int, '__init__')
        True

    Why this function needed? CPython implements int.__init__ by Descriptor
    but PyPy implements it by pure Python code.
    """
    ...

class DefaultValue:
    """A simple wrapper for default value of the parameters of overload functions."""
    def __init__(self, value: str) -> None:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    


class TypeAliasForwardRef:
    """Pseudo typing class for autodoc_type_aliases.

    This avoids the error on evaluating the type inside `get_type_hints()`.
    """
    def __init__(self, name: str) -> None:
        ...
    
    def __call__(self) -> None:
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __repr__(self) -> str:
        ...
    


class TypeAliasModule:
    """Pseudo module class for autodoc_type_aliases."""
    def __init__(self, modname: str, mapping: dict[str, str]) -> None:
        ...
    
    def __getattr__(self, name: str) -> Any:
        ...
    


class TypeAliasNamespace(dict[str, Any]):
    """Pseudo namespace class for autodoc_type_aliases.

    This enables to look up nested modules and classes like `mod1.mod2.Class`.
    """
    def __init__(self, mapping: dict[str, str]) -> None:
        ...
    
    def __getitem__(self, key: str) -> Any:
        ...
    


def signature(subject: Callable, bound_method: bool = ..., type_aliases: dict | None = ...) -> inspect.Signature:
    """Return a Signature object for the given *subject*.

    :param bound_method: Specify *subject* is a bound method or not
    """
    ...

def evaluate_signature(sig: inspect.Signature, globalns: dict | None = ..., localns: dict | None = ...) -> inspect.Signature:
    """Evaluate unresolved type annotations in a signature object."""
    ...

def stringify_signature(sig: inspect.Signature, show_annotation: bool = ..., show_return_annotation: bool = ..., unqualified_typehints: bool = ...) -> str:
    """Stringify a Signature object.

    :param show_annotation: If enabled, show annotations on the signature
    :param show_return_annotation: If enabled, show annotation of the return value
    :param unqualified_typehints: If enabled, show annotations as unqualified
                                  (ex. io.StringIO -> StringIO)
    """
    ...

def signature_from_str(signature: str) -> inspect.Signature:
    """Create a Signature object from string."""
    ...

def signature_from_ast(node: ast.FunctionDef, code: str = ...) -> inspect.Signature:
    """Create a Signature object from AST *node*."""
    ...

def getdoc(obj: Any, attrgetter: Callable = ..., allow_inherited: bool = ..., cls: Any = ..., name: str | None = ...) -> str | None:
    """Get the docstring for the object.

    This tries to obtain the docstring for some kind of objects additionally:

    * partial functions
    * inherited docstring
    * inherited decorated methods
    """
    ...

