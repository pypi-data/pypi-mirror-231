"""
This type stub file was generated by pyright.
"""

from typing import Any, TYPE_CHECKING
from docutils.parsers.rst import directives
from sphinx.directives import ObjectDescription
from sphinx.domains import Domain
from sphinx.roles import XRefRole
from sphinx.util.docutils import SphinxDirective
from collections.abc import Iterator
from docutils.nodes import Element, Node
from sphinx.addnodes import desc_signature, pending_xref
from sphinx.application import Sphinx
from sphinx.builders import Builder
from sphinx.environment import BuildEnvironment
from sphinx.util.typing import OptionSpec

"""The JavaScript domain."""
if TYPE_CHECKING:
    ...
logger = ...
class JSObject(ObjectDescription[tuple[str, str]]):
    """
    Description of a JavaScript object.
    """
    has_arguments = ...
    allow_nesting = ...
    option_spec: OptionSpec = ...
    def get_display_prefix(self) -> list[Node]:
        ...
    
    def handle_signature(self, sig: str, signode: desc_signature) -> tuple[str, str]:
        """Breaks down construct signatures

        Parses out prefix and argument list from construct definition. The
        namespace and class will be determined by the nesting of domain
        directives.
        """
        ...
    
    def add_target_and_index(self, name_obj: tuple[str, str], sig: str, signode: desc_signature) -> None:
        ...
    
    def get_index_text(self, objectname: str, name_obj: tuple[str, str]) -> str:
        ...
    
    def before_content(self) -> None:
        """Handle object nesting before content

        :py:class:`JSObject` represents JavaScript language constructs. For
        constructs that are nestable, this method will build up a stack of the
        nesting hierarchy so that it can be later de-nested correctly, in
        :py:meth:`after_content`.

        For constructs that aren't nestable, the stack is bypassed, and instead
        only the most recent object is tracked. This object prefix name will be
        removed with :py:meth:`after_content`.

        The following keys are used in ``self.env.ref_context``:

            js:objects
                Stores the object prefix history. With each nested element, we
                add the object prefix to this list. When we exit that object's
                nesting level, :py:meth:`after_content` is triggered and the
                prefix is removed from the end of the list.

            js:object
                Current object prefix. This should generally reflect the last
                element in the prefix history
        """
        ...
    
    def after_content(self) -> None:
        """Handle object de-nesting after content

        If this class is a nestable object, removing the last nested class prefix
        ends further nesting in the object.

        If this class is not a nestable object, the list of classes should not
        be altered as we didn't affect the nesting levels in
        :py:meth:`before_content`.
        """
        ...
    


class JSCallable(JSObject):
    """Description of a JavaScript function, method or constructor."""
    has_arguments = ...
    doc_field_types = ...


class JSConstructor(JSCallable):
    """Like a callable but with a different prefix."""
    allow_nesting = ...
    def get_display_prefix(self) -> list[Node]:
        ...
    


class JSModule(SphinxDirective):
    """
    Directive to mark description of a new JavaScript module.

    This directive specifies the module name that will be used by objects that
    follow this directive.

    Options
    -------

    no-index
        If the ``:no-index:`` option is specified, no linkable elements will be
        created, and the module won't be added to the global module index. This
        is useful for splitting up the module definition across multiple
        sections or files.

    :param mod_name: Module name
    """
    has_content = ...
    required_arguments = ...
    optional_arguments = ...
    final_argument_whitespace = ...
    option_spec: OptionSpec = ...
    def run(self) -> list[Node]:
        ...
    


class JSXRefRole(XRefRole):
    def process_link(self, env: BuildEnvironment, refnode: Element, has_explicit_title: bool, title: str, target: str) -> tuple[str, str]:
        ...
    


class JavaScriptDomain(Domain):
    """JavaScript language domain."""
    name = ...
    label = ...
    object_types = ...
    directives = ...
    roles = ...
    initial_data: dict[str, dict[str, tuple[str, str]]] = ...
    @property
    def objects(self) -> dict[str, tuple[str, str, str]]:
        ...
    
    def note_object(self, fullname: str, objtype: str, node_id: str, location: Any = ...) -> None:
        ...
    
    @property
    def modules(self) -> dict[str, tuple[str, str]]:
        ...
    
    def note_module(self, modname: str, node_id: str) -> None:
        ...
    
    def clear_doc(self, docname: str) -> None:
        ...
    
    def merge_domaindata(self, docnames: list[str], otherdata: dict[str, Any]) -> None:
        ...
    
    def find_obj(self, env: BuildEnvironment, mod_name: str, prefix: str, name: str, typ: str | None, searchorder: int = ...) -> tuple[str | None, tuple[str, str, str] | None]:
        ...
    
    def resolve_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder, typ: str, target: str, node: pending_xref, contnode: Element) -> Element | None:
        ...
    
    def resolve_any_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder, target: str, node: pending_xref, contnode: Element) -> list[tuple[str, Element]]:
        ...
    
    def get_objects(self) -> Iterator[tuple[str, str, str, str, str, int]]:
        ...
    
    def get_full_qualified_name(self, node: Element) -> str | None:
        ...
    


def setup(app: Sphinx) -> dict[str, Any]:
    ...

