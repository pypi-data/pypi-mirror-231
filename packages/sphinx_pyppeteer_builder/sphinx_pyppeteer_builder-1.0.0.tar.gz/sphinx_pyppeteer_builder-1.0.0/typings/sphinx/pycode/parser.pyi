"""
This type stub file was generated by pyright.
"""

import ast
from typing import Any

"""Utilities parsing and analyzing Python code."""
comment_re = ...
indent_re = ...
emptyline_re = ...
def filter_whitespace(code: str) -> str:
    ...

def get_assign_targets(node: ast.AST) -> list[ast.expr]:
    """Get list of targets from Assign and AnnAssign node."""
    ...

def get_lvar_names(node: ast.AST, self: ast.arg | None = ...) -> list[str]:
    """Convert assignment-AST to variable names.

    This raises `TypeError` if the assignment does not create new variable::

        ary[0] = 'foo'
        dic["bar"] = 'baz'
        # => TypeError
    """
    ...

def dedent_docstring(s: str) -> str:
    """Remove common leading indentation from docstring."""
    ...

class Token:
    """Better token wrapper for tokenize module."""
    def __init__(self, kind: int, value: Any, start: tuple[int, int], end: tuple[int, int], source: str) -> None:
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    def match(self, *conditions: Any) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    


class TokenProcessor:
    def __init__(self, buffers: list[str]) -> None:
        ...
    
    def get_line(self, lineno: int) -> str:
        """Returns specified line."""
        ...
    
    def fetch_token(self) -> Token | None:
        """Fetch the next token from source code.

        Returns ``None`` if sequence finished.
        """
        ...
    
    def fetch_until(self, condition: Any) -> list[Token]:
        """Fetch tokens until specified token appeared.

        .. note:: This also handles parenthesis well.
        """
        ...
    


class AfterCommentParser(TokenProcessor):
    """Python source code parser to pick up comments after assignments.

    This parser takes code which starts with an assignment statement,
    and returns the comment for the variable if one exists.
    """
    def __init__(self, lines: list[str]) -> None:
        ...
    
    def fetch_rvalue(self) -> list[Token]:
        """Fetch right-hand value of assignment."""
        ...
    
    def parse(self) -> None:
        """Parse the code and obtain comment after assignment."""
        ...
    


class VariableCommentPicker(ast.NodeVisitor):
    """Python source code parser to pick up variable comments."""
    def __init__(self, buffers: list[str], encoding: str) -> None:
        ...
    
    def get_qualname_for(self, name: str) -> list[str] | None:
        """Get qualified name for given object as a list of string(s)."""
        ...
    
    def add_entry(self, name: str) -> None:
        ...
    
    def add_final_entry(self, name: str) -> None:
        ...
    
    def add_overload_entry(self, func: ast.FunctionDef) -> None:
        ...
    
    def add_variable_comment(self, name: str, comment: str) -> None:
        ...
    
    def add_variable_annotation(self, name: str, annotation: ast.AST) -> None:
        ...
    
    def is_final(self, decorators: list[ast.expr]) -> bool:
        ...
    
    def is_overload(self, decorators: list[ast.expr]) -> bool:
        ...
    
    def get_self(self) -> ast.arg | None:
        """Returns the name of the first argument if in a function."""
        ...
    
    def get_line(self, lineno: int) -> str:
        """Returns specified line."""
        ...
    
    def visit(self, node: ast.AST) -> None:
        """Updates self.previous to the given node."""
        ...
    
    def visit_Import(self, node: ast.Import) -> None:
        """Handles Import node and record the order of definitions."""
        ...
    
    def visit_ImportFrom(self, node: ast.ImportFrom) -> None:
        """Handles Import node and record the order of definitions."""
        ...
    
    def visit_Assign(self, node: ast.Assign) -> None:
        """Handles Assign node and pick up a variable comment."""
        ...
    
    def visit_AnnAssign(self, node: ast.AnnAssign) -> None:
        """Handles AnnAssign node and pick up a variable comment."""
        ...
    
    def visit_Expr(self, node: ast.Expr) -> None:
        """Handles Expr node and pick up a comment if string."""
        ...
    
    def visit_Try(self, node: ast.Try) -> None:
        """Handles Try node and processes body and else-clause.

        .. note:: pycode parser ignores objects definition in except-clause.
        """
        ...
    
    def visit_ClassDef(self, node: ast.ClassDef) -> None:
        """Handles ClassDef node and set context."""
        ...
    
    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:
        """Handles FunctionDef node and set context."""
        ...
    
    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> None:
        """Handles AsyncFunctionDef node and set context."""
        ...
    


class DefinitionFinder(TokenProcessor):
    """Python source code parser to detect location of functions,
    classes and methods.
    """
    def __init__(self, lines: list[str]) -> None:
        ...
    
    def add_definition(self, name: str, entry: tuple[str, int, int]) -> None:
        """Add a location of definition."""
        ...
    
    def parse(self) -> None:
        """Parse the code to obtain location of definitions."""
        ...
    
    def parse_definition(self, typ: str) -> None:
        """Parse AST of definition."""
        ...
    
    def finalize_block(self) -> None:
        """Finalize definition block."""
        ...
    


class Parser:
    """Python source code parser to pick up variable comments.

    This is a better wrapper for ``VariableCommentPicker``.
    """
    def __init__(self, code: str, encoding: str = ...) -> None:
        ...
    
    def parse(self) -> None:
        """Parse the source code."""
        ...
    
    def parse_comments(self) -> None:
        """Parse the code and pick up comments."""
        ...
    
    def parse_definition(self) -> None:
        """Parse the location of definitions from the code."""
        ...
    


