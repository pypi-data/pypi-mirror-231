<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Rasa Bot Inspector</title>

    <!-- External Stylesheets -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/styles/default.min.css"
    />

    <!-- Custom Styles -->
    <style>
      body {
        font-family: "Arial", sans-serif;
        line-height: 1;
        margin: 0;
        padding: 2em;
      }

      .tiny {
        font-size: 0.5em;
      }

      .content {
        max-width: 30em;
        margin-bottom: 1em;
      }

      .content-code {
        margin: 1em 1em;
      }

      .container {
        display: grid;
        grid-template-columns: 30% 50% 20%;
        gap: 2em;
      }

      table {
        width: 100%;
        border-spacing: 1em 0;
        border-collapse: separate;
      }

      th,
      td {
        padding: 0.5em;
        text-align: left;
        border-bottom: 1px solid #ccc;
      }

      .empty-row {
        text-align: center;
      }

      tbody tr:hover {
        background-color: #f7f7f7;
      }

      .bold {
        font-weight: bold;
      }

      code,
      pre {
        font-family: "Courier New", monospace;
        font-size: 0.9em;
        border-spacing: 1em 0;
      }
    </style>
  </head>

  <body>
    <div class="logged-in-box auth0-box logged-in">
      <h2>Happy chatting!</h2>
      <p>
        You can include the chat on your own website using the following code
        (<a
          href="https://rasa.com/docs/rasa/connectors/your-own-website#chat-widget"
          >rasa documentation</a
        >):
      </p>
      <pre class="code">
&lt;div id="rasa-chat-widget" data-websocket-url="https://example.com/"&gt;&lt;/div&gt;
&lt;script src="https://unpkg.com/@rasahq/rasa-chat" type="application/javascript"&gt;&lt;/script&gt;
      </pre>
    </div>

    <div class="container">
      <div>
        <p class="content bold">Stack (top is active):</p>
        <table>
          <thead>
            <tr>
              <th>ID</th>
              <th>Flow</th>
              <th>Step Id</th>
            </tr>
          </thead>
          <tbody id="stack-frames"></tbody>
        </table>
        <p class="content bold">Slots:</p>
        <table>
          <thead>
            <tr>
              <th>Slot</th>
              <th>Value</th>
            </tr>
          </thead>
          <tbody id="slots"></tbody>
        </table>
        <div>
          <p class="content bold">End-2-End Test:</p>
          <div class="content-code">
            <pre
              class="code language-json"
            ><code id="e2e-test">No test yet</code></pre>
          </div>
        </div>
        <div>
          <p class="content bold">Tracker State:</p>
          <div class="content-code">
            <pre
              class="code language-json"
            ><code id="json-data">No story yet</code></pre>
          </div>
        </div>
      </div>
      <div>
        <p class="content bold">Current Flow:</p>
        <div>
          <input type="checkbox" id="exclude-patterns" name="exclude-patterns" checked />
          <label for="exclude-patterns">exclude patterns</label>
        </div>
        <div>
          <pre class="mermaid" id="flow"></pre>
        </div>
      </div>
      <div>
        <div id="chat-container">
          <!-- place holder for chat window. just making sure it doesn't overlap-->
        </div>
      </div>
    </div>
    <div
      id="rasa-chat-widget"
      data-websocket-url=""
      data-default-open="true"
      data-height="500"
    ></div>

    <!-- External Libraries -->
    <script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://unpkg.com/mermaid@10.3.1/dist/mermaid.min.js"></script>

    <script>
      async function updateChatDiv() {
        const chatDiv = document.getElementById("rasa-chat-widget");
        const websocketUrl = window.location.origin.replace("http", "ws");
        const maxHeight = document.documentElement.scrollHeight - 150;
        chatDiv.setAttribute("data-websocket-url", websocketUrl);
        chatDiv.setAttribute("data-height", maxHeight);
      }

      async function fetchFlows() {
        try {
          const response = await fetch("/flows");
          if (!response?.ok) {
            console.error("Error: Flows not found");
            return [];
          }
          return await response.json();
        } catch (error) {
          console.error(error);
          return [];
        }
      }

      async function fetchStory() {
        const conversationId = window.rasaChatSessionId || "";
        try {
          const response = await fetch(
            `/conversations/${conversationId}/story`
          );
          const data = await response.text();
          const storyBlock = document.getElementById("json-data");
          if (storyBlock.textContent !== data) {
            storyBlock.textContent = data;
            if (window.hljs) {
              hljs.highlightElement(storyBlock, { language: "yaml" });
            }
          }
        } catch (error) {
          console.error("Error fetching story:", error);
        }
      }

      function currentSettings() {
        return {
          excludePatterns: document.getElementById("exclude-patterns").checked,
        };
      }

      async function fetchTracker() {
        const conversationId = window.rasaChatSessionId || "";

        try {
          const response = await fetch(
            `/conversations/${conversationId}/tracker?start_session=false`
          );

          if (!response?.ok) {
            console.error("Error: Story not found");
            return;
          }

          const data = await response.json();

          if (JSON.stringify(previousTrackerState) !== JSON.stringify(data) || JSON.stringify(previousSettings) !== JSON.stringify(currentSettings())) {
            previousTrackerState = data;
            previousSettings = currentSettings();

            updateE2ETest(data);
            updateSlots(data.slots);
            updateStackFrames(data.slots.dialogue_stack || []);
            await renderMermaidDiagram(data.slots.dialogue_stack || [],data.slots);
          }
        } catch (error) {
          console.error(error);
        }
      }

      function updateE2ETest(data) {
        const e2eTest = document.getElementById("e2e-test");
        const steps = data.events
          .map((event) => {
            if (event.event === "user") return { user: event.text };
            if (event.event === "bot") {
              return event.metadata?.utter_action
                ? { utter: event.metadata.utter_action }
                : { utter: event.text };
            }
          })
          .filter(Boolean);

        const e2eTestCase = {
          test_cases: [
            {
              test_case: data.sender_id,
              steps: steps,
            },
          ],
        };
        e2eTest.textContent = jsyaml.dump(e2eTestCase, { noArrayIndent: true });

        if (window.hljs) hljs.highlightElement(e2eTest);
      }

      function updateSlots(slots) {
        const root = document.getElementById("slots");
        root.innerHTML = "";
        const sortedSlotNames = Object.keys(slots).sort();

        sortedSlotNames.forEach((name) => {
          const slotValue = JSON.stringify(slots[name], null, 2);
          if (name != "dialogue_stack" && slotValue !== "null") {
            root.insertAdjacentHTML(
              "beforeend",
              `<tr><td>${name}</td><td>${slotValue}</td></tr>`
            );
          }
        });

        root.insertAdjacentHTML(
          "beforeend",
          `<tr><td>< all other slots ></td><td>None</td></tr>`
        );
      }

      function updateStackFrames(stackFrames) {
        const stackEl = document.getElementById("stack-frames");
        stackEl.innerHTML = "";

        if (!stackFrames.length) {
          stackEl.insertAdjacentHTML(
            "afterbegin",
            `<tr><td colspan=3 class="empty-row">-</td></tr>`
          );
        } else {
          stackFrames.forEach((frame, i) => {
            stackEl.insertAdjacentHTML(
              "afterbegin",
              `<tr><td class="tiny">${frame.frame_id}</td><td>${
                frame.flow_id
              }</td><td>${frame.step_id}</td></tr>`
            );
          });
        }
      }

      function keepShort(str, rough_limit=35) {
        // if a string is too long, use an elipsis
        if(str.length > rough_limit){
          return str.substring(0, rough_limit) + "...";
        }
        return str;
      }

      const toHtmlEntities = (str) => 
        [...str].map( v => `#${v.charCodeAt(0)};`).join(``);

      let inject = (str, obj) => str.replace(/{{context\.(.*?)}}/g, (x,g)=> obj[g]);

      function firstNonPatternFrame(stackFrames) {
        let frameIndex = stackFrames.length - 1;
        while (frameIndex >= 0 && stackFrames[frameIndex]?.flow_id?.startsWith("pattern_")) {
          frameIndex--;
        }
        return frameIndex;
      }

      async function renderMermaidDiagram(stackFrames, slots) {

        let excludePatterns = document.getElementById("exclude-patterns").checked;

        let frameIndex = excludePatterns ? firstNonPatternFrame(stackFrames) : stackFrames.length - 1;
        let activeFlow = stackFrames[frameIndex]?.flow_id;
        let activeStep = stackFrames[frameIndex]?.step_id;
        let currentContext = stackFrames[frameIndex];
        let flows = await flowsData;
        // find flow by going through array and checking for the id field
        let flow = flows.find((flow) => flow.id === activeFlow);
        var mermaidText = `---
title: ${flow?.id ?? "No Flow"}
---
flowchart TD
classDef collect_information stroke-width:1px
classDef action fill:#FBFCFD,stroke:#A0B8CF
classDef link fill:#f43
classDef slot fill:#aaa
classDef active stroke:#5A17ED,stroke-width:3px,stroke-dasharray: 5 3
        `;

        if (flow) {
          flow.steps.forEach((step) => {
            if (step.collect_information) {
              var slotValue = slots[step.collect_information]
                ? `'${slots[step.collect_information]}'`
                : "\uD83D\uDCAC";
              mermaidText += `${step.id}["${toHtmlEntities(keepShort(inject(step.collect_information, currentContext)))}\n${keepShort(slotValue)}"]:::collect_information\n`;
            }
            if (step.action) {
              mermaidText += `${step.id}["${toHtmlEntities(keepShort(inject(step.action, currentContext)))}"]:::action\n`;
            }
            if (step.link) {
              mermaidText += `${step.id}["\uD83D\uDD17 ${step.link}"]:::link\n`;
            }
            if (step.set_slots) {
              mermaidText += `${step.id}["\uD83E\uDEA3 ${step.id}"]:::slot\n`;
            }

            if (step.id === activeStep) {
              mermaidText += `class ${step.id} active\n`;
            }

            // if next is an id, then it is a link
            if (step.next && typeof step.next === "string") {
              mermaidText += `${step.id} --> ${step.next}\n`;
            }
            // if next is an array, then it is a list of conditions
            if (step.next && Array.isArray(step.next)) {
              step.next.forEach((condition) => {
                if (condition.then) {
                  mermaidText += `${step.id} -->|${toHtmlEntities(inject(condition.if, currentContext))}| ${condition.then}\n`;
                }
                if (condition.else) {
                  mermaidText += `${step.id} -->|else| ${condition.else}\n`;
                }
              })
            }
          })
        }
        let flowEl = document.getElementById("flow");
        console.log(mermaidText);
        const { svg } = await mermaid.render("graphDiv", mermaidText);
        flowEl.innerHTML = svg;
      }

      async function updateData() {
        await Promise.all([fetchStory(), fetchTracker()]);
        setTimeout(updateData, 1000);
      }

      mermaid.initialize({ startOnLoad: false });

      let previousTrackerState = null;
      let previousSettings = null;
      let flowsData = fetchFlows();

      // Call functions initially
      updateChatDiv();
      updateData();
    </script>

    <script
      src="https://unpkg.com/@rasahq/rasa-chat"
      type="application/javascript"
    ></script>
  </body>
</html>
