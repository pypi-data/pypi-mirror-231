#!/usr/bin/python3
# -*- coding: utf-8 -*-

import sys
import time
import random
import logging
import ssl;ssl._create_default_https_context = ssl._create_unverified_context
from qingcloud.iaas.connection import APIConnection
from utils import decorator
from utils.log import logger

from qingcloud.iaas import APIConnection
from qingcloud.misc.json_tool import json_dump,json_load
from qingcloud.conn.auth import QuerySignatureAuthHandler

class RestClient(APIConnection):

    api_version = None
    LOG = logging.getLogger(__name__)

    def __init__(self,qy_access_key_id, qy_secret_access_key, zone,
                 host="api.qingcloud.com", port=443, protocol="https",
                 pool=None, expires=None,
                 retry_time=2, http_socket_timeout=60, debug=False,
                 credential_proxy_host="169.254.169.254", credential_proxy_port=80):
        """
        初始化SDK连接
        """
        super(APIConnection, self).__init__(
            qy_access_key_id, qy_secret_access_key, host, port, protocol,
            pool, expires, http_socket_timeout, debug, credential_proxy_host, credential_proxy_port)

        # 设置默认区域
        self.zone = zone
        # 设置重试时间
        self.retry_time = retry_time

        if not self.qy_access_key_id and not self.qy_secret_access_key:
            self._check_token()

        else:
            self._auth_handler = QuerySignatureAuthHandler(self.host,
                                                           self.qy_access_key_id,
                                                           self.qy_secret_access_key)

    def send_request(self, action, body, url="/iaas/", verb="GET"):
        """
        重写父类发送请求方法,添加响应信息到allure的测试报告中
        @param action: 动作
        @param body: 请求参数
        """
        request = body
        request['action'] = action
        request.setdefault('zone', self.zone)
        if self.debug:
            logger.info(json_dump(request))
            sys.stdout.flush()
        if self.expires:
            request['expires'] = self.expires

        retry_time = 0
        while retry_time < self.retry_time:
            # Use binary exponential backoff to desynchronize client requests
            next_sleep = random.random() * (2 ** retry_time)
            try:
                response = self.send(verb, url, request)
                if response.status == 200:
                    resp_str = response.read()
                    if type(resp_str) != str:
                        resp_str = resp_str.decode()
                    if self.debug:
                        logger.info(resp_str)
                        sys.stdout.flush()
                    if resp_str and json_load(resp_str).get("ret_code") in (5000, 5100) and retry_time < self.retry_time - 1:
                        # 5000: INTERNAL ERROR
                        # 5100: SERVER BUSY
                        self._get_conn(self.host, self.port)
                        time.sleep(next_sleep)
                        retry_time += 1
                        continue
                    # return json_load(resp_str) if resp_str else ""
                    else:
                        res = ""
                    return res
            except Exception as e:
                logger.error(f"send request exception,{str(e)}")
                if retry_time < self.retry_time - 1:
                    self._get_conn(self.host, self.port)
                else:
                    raise

            time.sleep(next_sleep)
            retry_time += 1