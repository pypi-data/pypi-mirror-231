# coding: utf-8

"""
    Kubernetes

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: unversioned
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Dict, List, Optional, Union
from pydantic import BaseModel, Field, StrictStr, conbytes, conlist, constr, validator

class IoK8sApiCertificatesV1beta1CertificateSigningRequestSpec(BaseModel):
    """
    This information is immutable after the request is created. Only the Request and Usages fields can be set on creation, other fields are derived by Kubernetes and cannot be modified by users.  # noqa: E501
    """
    extra: Optional[Dict[str, conlist(StrictStr)]] = Field(None, description="Extra information about the requesting user. See user.Info interface for details.")
    groups: Optional[conlist(StrictStr)] = Field(None, description="Group information about the requesting user. See user.Info interface for details.")
    request: Union[conbytes(strict=True), constr(strict=True)] = Field(..., description="Base64-encoded PKCS#10 CSR data")
    signer_name: Optional[StrictStr] = Field(None, alias="signerName", description="Requested signer for the request. It is a qualified name in the form: `scope-hostname.io/name`. If empty, it will be defaulted:  1. If it's a kubelet client certificate, it is assigned     \"kubernetes.io/kube-apiserver-client-kubelet\".  2. If it's a kubelet serving certificate, it is assigned     \"kubernetes.io/kubelet-serving\".  3. Otherwise, it is assigned \"kubernetes.io/legacy-unknown\". Distribution of trust for signers happens out of band. You can select on this field using `spec.signerName`.")
    uid: Optional[StrictStr] = Field(None, description="UID information about the requesting user. See user.Info interface for details.")
    usages: Optional[conlist(StrictStr)] = Field(None, description="allowedUsages specifies a set of usage contexts the key will be valid for. See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3      https://tools.ietf.org/html/rfc5280#section-4.2.1.12")
    username: Optional[StrictStr] = Field(None, description="Information about the requesting user. See user.Info interface for details.")
    __properties = ["extra", "groups", "request", "signerName", "uid", "usages", "username"]

    @validator('request')
    def request_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$", value):
            raise ValueError(r"must validate the regular expression /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> IoK8sApiCertificatesV1beta1CertificateSigningRequestSpec:
        """Create an instance of IoK8sApiCertificatesV1beta1CertificateSigningRequestSpec from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each value in extra (dict of array)
        _field_dict_of_array = {}
        if self.extra:
            for _key in self.extra:
                if self.extra[_key]:
                    _field_dict_of_array[_key] = [
                        _item.to_dict() for _item in self.extra[_key]
                    ]
            _dict['extra'] = _field_dict_of_array
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> IoK8sApiCertificatesV1beta1CertificateSigningRequestSpec:
        """Create an instance of IoK8sApiCertificatesV1beta1CertificateSigningRequestSpec from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return IoK8sApiCertificatesV1beta1CertificateSigningRequestSpec.parse_obj(obj)

        _obj = IoK8sApiCertificatesV1beta1CertificateSigningRequestSpec.parse_obj({
            "extra": obj.get("extra"),
            "groups": obj.get("groups"),
            "request": obj.get("request"),
            "signer_name": obj.get("signerName"),
            "uid": obj.get("uid"),
            "usages": obj.get("usages"),
            "username": obj.get("username")
        })
        return _obj


