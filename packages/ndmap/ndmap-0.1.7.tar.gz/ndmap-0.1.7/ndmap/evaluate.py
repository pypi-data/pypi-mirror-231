"""
Evaluate
--------

Table and series evaluation

"""

from math import factorial

from typing import TypeAlias
from typing import Callable
from typing import Optional
from typing import Union

from multimethod import multimethod

import torch
from torch import Tensor

from ndmap.derivative import derivative
from ndmap.signature import signature
from ndmap.signature import get


State       : TypeAlias = Tensor
Knobs       : TypeAlias = list[Tensor]
Point       : TypeAlias = list[Tensor]
Delta       : TypeAlias = list[Tensor]
Table       : TypeAlias = list
Series      : TypeAlias = dict[tuple[int, ...], Tensor]
Signature   : TypeAlias = Union[list[tuple[int, ...]], list[tuple[tuple[int, ...], float]]]
Mapping     : TypeAlias = Callable
Observable  : TypeAlias = Callable
Hamiltonian : TypeAlias = Callable


@multimethod
def evaluate(table:Table,
             delta:Delta) -> Tensor:
    """
    Evaluate input derivative table representation at a given delta deviation

    Note, input table is expected to represent a vector or scalar valued function

    Parameters
    ----------
    table: Table
        input derivative table representation
    delta: Delta
        delta deviation

    Returns
    -------
    Tensor

    Examples
    --------
    >>> import torch
    >>> from ndmap.derivative import derivative
    >>> def fn(x, y):
    ...    x1, x2 = x
    ...    y1, y2 = y
    ...    return torch.stack([x1*(1 + y1), x2*(1 + y2)])
    >>> x = torch.tensor([0.0, 0.0])
    >>> y = torch.zeros_like(x)
    >>> t = derivative((2, 1), fn, x, y)
    >>> dx = 1.0E-3*torch.ones_like(x)
    >>> dy = 1.0E-3*torch.ones_like(x)
    >>> torch.allclose(fn(x + dx, y + dy), evaluate(t, [dx, dy]))
    True

    """
    return sum(evaluate([i], subtable, delta) for i, subtable in enumerate(table))


@multimethod
def evaluate(index:list[int], table:Table, delta:Delta):
    """ (auxiliary) """
    return sum(evaluate(index + [i], subtable, delta) for i, subtable in enumerate(table))


@multimethod
def evaluate(index:list[int], table:Tensor, delta:Delta):
    """ (auxiliary) """
    total = 1.0
    for count, order in enumerate(index):
        total *= 1.0/factorial(order)
        value  = delta[count]
        if value.ndim > 0:
            for _ in range(order):
                table = table @ value
        else:
            for _ in range(order):
                table = table * value
    return total*table


@multimethod
def evaluate(series:Series,
             delta:Delta,
             epsilon:Optional[float]=None) -> Tensor:
    """
    Evaluate series representation at a given deviation delta

    Note, input series is expected to represent a vector valued function
    For epsilon != None, fast evaluation is performed

    Parameters
    ----------
    series: Series
        input series representation
    delta: Delta
        delta deviation
    epsilon: Optional[float], non-negative, default=None
        fast series evaluation / tolerance epsilon

    Returns
    -------
    Tensor

    Examples
    --------
    >>> import torch
    >>> from ndmap.derivative import derivative
    >>> from ndmap.series import series
    >>> def fn(x, y):
    ...    x1, x2 = x
    ...    y1, y2 = y
    ...    return torch.stack([x1*(1 + y1), x2*(1 + y2)])
    >>> x = torch.tensor([0.0, 0.0])
    >>> y = torch.zeros_like(x)
    >>> t = derivative((2, 1), fn, x, y)
    >>> s = series((2, 2), (2, 1), t)
    >>> dx = 1.0E-3*torch.ones_like(x)
    >>> dy = 1.0E-3*torch.ones_like(x)
    >>> torch.allclose(fn(x + dx, y + dy), evaluate(s, [dx, dy]))

    """
    state = torch.cat(delta)

    if epsilon is not None:
        state = state + 0*(epsilon + torch.sin(state.sum()))
        index = torch.tensor([*series.keys()], dtype=torch.int64, device=state.device)
        value = torch.stack([*series.values()])
        return (value.T*(state**index).prod(-1)).sum(-1)

    total, *_ = series.values()
    total = torch.zeros_like(total)
    for key, value in series.items():
        local = torch.ones_like(state).prod()
        for i, x in zip(key, state):
            for _ in range(i):
                local = x * local
        total = total + value * local
    return total


def table(dimension:tuple[int, ...],
          order:tuple[int, ...],
          series:Series, *,
          epsilon:Optional[float]=None,
          jacobian:Optional[Callable]=None) -> Table:
    """
    Generate derivative table representation from a given series representation

    Note, table is generated by taking derivatives of evaluated series at zero deviation delta.
    For epsilon != None can be used for fast series evaluation, but can generate incorrect table

    Parameters
    ----------
    dimension: tuple[int, ...], positive
        dimensions
    order: tuple[int, ...], non-negative
        maximum derivative orders
    series: Series
        input series representation
    epsilon: Optional[float], non-negative, default=None
        fast series evaluation / tolerance epsilon
    jacobian: Optional[Callable]
        torch.func.jacfwd (default) or torch.func.jacrev

    Returns
    -------
    Table

    Examples
    --------
    >>> import torch
    >>> from ndmap.derivative import derivative
    >>> from ndmap.series import series
    >>> def fn(x, y):
    ...    x1, x2 = x
    ...    y1, y2 = y
    ...    return torch.stack([x1*(1 + y1), x2*(1 + y2)])
    >>> x = torch.tensor([0.0, 0.0])
    >>> y = torch.zeros_like(x)
    >>> t = derivative((2, 1), fn, x, y)
    >>> s = series((2, 2), (2, 1), t)
    >>> t = table((2, 2), (2, 1), s)
    >>> dx = 1.0E-3*torch.ones_like(x)
    >>> dy = 1.0E-3*torch.ones_like(x)
    >>> torch.allclose(fn(x + dx, y + dy), evaluate(t, [dx, dy]))
    True

    """
    jacobian = torch.func.jacfwd if jacobian is None else jacobian

    def function(*args):
        return evaluate(series, [*args], epsilon=epsilon)

    value, *_ = series.values()
    delta = [torch.zeros(i, dtype=value.dtype, device=value.device) for i in dimension]

    return derivative(order, function, delta, intermediate=True, jacobian=jacobian)


def compare(probe:Table, other:Table) -> bool:
    """
    Compare tables

    Parameters
    ----------
    probe, other: Table
        tables to compare

    Returns
    -------
    bool

    Examples
    --------
    >>> import torch
    >>> from ndmap.derivative import derivative
    >>> def fn(x, y):
    ...    x1, x2 = x
    ...    y1, y2 = y
    ...    return torch.stack([x1*(1 + y1), x2*(1 + y2)])
    >>> x = torch.tensor([0.0, 0.0])
    >>> y = torch.zeros_like(x)
    >>> t = derivative((2, 1), fn, x, y)
    >>> compare(t, t)
    True

    """
    for i in signature(probe):
        x = get(probe, i)
        y = get(other, i)
        if isinstance(x, Tensor) and isinstance(y, Tensor):
            if not torch.allclose(x, y):
                return False
    return True
