# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_enum.ipynb.

# %% auto 0
__all__ = ['InheritableEnumMeta', 'RelDirsType', 'RelDirsEnumMeta', 'RelDirsEnum']

# %% ../nbs/05_enum.ipynb 4
import os, copy, inspect
from string import Template
from types import MethodType
from typing import Any, Dict, List, Type, Union, Optional, Iterable
from dataclasses import dataclass, field, InitVar, Field
from enum import Enum, EnumMeta, _EnumDict, member

# %% ../nbs/05_enum.ipynb 6
from nbdirs.cons import (
    __RESTORE__, __MEMBERS__, __INHERITABLE_MEMBERS__, _MEMBER_NAMES_,
    ROOT, RDIR, VALUE, DROOT, VERBOSE
)
from .atyp import (StrTmpl, DirLike, DirLikeQ, Mixin, IterStr, StrQ)
from .dirs import Dir, RelDir, ROOT_DIR
from .dirs import NBKS_DIR, EXPL_DIR, DATA_DIR, RSLT_DIR, FIGS_DIR

# %% ../nbs/05_enum.ipynb 8
from nbdirs.utils import (
    isdunder, vvalue, newedict, __restore__, getmembers, getnames, getmeminfo
)

# %% ../nbs/05_enum.ipynb 10
from .mixs import (roothook, ROOT_MIXIN)

# %% ../nbs/05_enum.ipynb 12
class InheritableEnumMeta(EnumMeta):
    def _check_for_existing_members_(class_name, bases):
        # Inheritance requires existing members!
        pass

    @classmethod
    def __prepare__(metacls, name, bases, **kwargs):
        clsdict = newedict(name)
        
        members, _ = getmeminfo(bases)
        for mem, val in members.items():
            if mem in clsdict: continue
            clsdict[mem] = val.value

        setattr(clsdict, __INHERITABLE_MEMBERS__, members.copy())
        return clsdict

    def __new__(cls, name, bases, classdict):          
        newcls = super().__new__(cls, name, bases, classdict)
        members, _ = getmeminfo(bases)
        setattr(classdict, __INHERITABLE_MEMBERS__, members.copy())
        return newcls

# %% ../nbs/05_enum.ipynb 14
class RelDirsType(type):
    root: DirLikeQ = None # ROOT_DIR.deepcopy()
    mixs: List[Mixin] = [ROOT_MIXIN]

    @classmethod
    def __delval__(metacls, clsdict, key):
        if key in clsdict:
            clsdict.__delitem__(key)
            clsdict._member_names.pop(key)            
            # delattr(clsdict._member_names, key)

    @classmethod
    def __copyval__(metacls, val, mixins = None, *args, **kwargs) -> Any:
        mixins = mixins or getattr(metacls, 'mixs', [])
        newval = copy.deepcopy(vvalue(val))
        for (mix, hook) in mixins:
            if isinstance(newval, mix):
                newval = hook(newval, *args, **kwargs)

        return newval
    
    @classmethod
    def __updateval__(metacls, clsdict, val, mixins = None, *args, **kwargs) -> member:
        asmemb= kwargs.get('asmember', False)
        newval = metacls.__copyval__(val, mixins, *args, **kwargs)        
        return member(newval) if asmemb else newval

    @classmethod
    def __getroot__(metacls, clsdict, **kwargs) -> DirLike: 
        rkws = kwargs.get(ROOT, None)
        edir = clsdict.get(ROOT, None) # getattr(clsdict, ROOT, None)
        rdir = clsdict.get(RDIR, None) # getattr(clsdict, RDIR, None)
        mdir = getattr(metacls, ROOT, None)
        root = rkws or edir or rdir or mdir or DROOT
        return root 
        
    @classmethod
    def __rootdir__(metacls, clsdict, **kwargs):
        root = metacls.__getroot__(clsdict, **kwargs)
        if isinstance(root, str):
            root = RelDir(root=root, abrv=ROOT, desc='The root directory')
        return root

    @staticmethod
    def __updateroot__(val, root):
        val = copy.deepcopy(vvalue(val))
        if isinstance(val, RelDir): 
            val.update(root=root, inplace=True)
        return member(val)
    
    @classmethod
    def __setdict__(metacls, clsdict, key, val = None, *args, **kwargs):
        if key in clsdict or key in clsdict._member_names:
            if val is None: 
                val = clsdict.__getitem__(key)
            
            try: metacls.__delval__(clsdict, key)
            except AttributeError: pass

        val = metacls.__updateval__(clsdict, val, asmember=True, *args, **kwargs)
        clsdict.__setitem__(key, val)
        clsdict._member_names[key] = clsdict[key]
        return clsdict
    
    @classmethod
    def __setroot__(metacls, clsdict, root):
        for k in (ROOT, RDIR): metacls.__delval__(clsdict, k)
        setattr(clsdict, ROOT, root)
        clsdict = metacls.__setdict__(clsdict, RDIR, root, root=root)
        return clsdict
    
    @classmethod
    def __copydict__(metacls, clsdict, *args, **kwargs):
        newdict = newedict(clsdict._cls_name)
        mixins = kwargs.get('mixins', []) or getattr(metacls, 'mixs', [])

        for k, v in clsdict.items():
            newdict[k] = metacls.__copyval__(v, mixins,  *args, **kwargs)            
        
        return newdict

# %% ../nbs/05_enum.ipynb 16
class RelDirsEnumMeta(RelDirsType, EnumMeta):
    root: DirLikeQ = ROOT_DIR.deepcopy()
    mixs: List[Mixin] = [ROOT_MIXIN]
    
    def _check_for_existing_members_(class_name, bases): 
        pass
    
    @classmethod
    def __prepare__(metacls, name, bases, **kwargs) -> dict:
        clsdict = newedict(name)
        root = metacls.__rootdir__(clsdict, **kwargs)
        clsdict = metacls.__setroot__(clsdict, root)

        # NOTE: this does inheritance
        members, _ = getmeminfo(bases)
        if RDIR in clsdict:
            metacls.__delval__(clsdict, RDIR)
        for mem, val in members.items():
            if isdunder(mem): continue
            if mem == RDIR: continue
            clsdict = metacls.__setdict__(clsdict, mem, val, root=root)
        return clsdict
    
    def __new__(metacls, name, bases, clsdict, *, root: DirLikeQ = None, **kwargs): 
        root = metacls.__rootdir__(clsdict, root=root, **kwargs)
        clsdict = metacls.__setroot__(clsdict, root)
        newdict = metacls.__copydict__(clsdict, root=root, **kwargs)
        if RDIR not in newdict:
            newdict = metacls.__setdict__(newdict, RDIR, root, root=root)
        newcls = super().__new__(metacls, name, bases, newdict)
        return newcls
    
    @classmethod
    def _missing_(cls, value):
        return None
    
    @property
    def dirnames(cls) -> list: return sorted([attr for attr in cls._member_names_])

    @property
    def dirs(cls) -> dict: return {d: getattr(cls, d).value for d in sorted(cls._member_names_)}
    
    @property
    def todict(cls) -> Dict[str, RelDir]: return {k: v.value for k, v in cls.__members__.items()}

    @property
    def clsname(cls) -> str:  return cls.__name__
    
    def __contains__(cls, key):
        return key in cls._member_map_ or key in cls._member_names_ or key in cls.dirs.values()
    
    def makedirs(self, verbose: bool = False):
        dirs = self.dirs
        for name, path in dirs.items():
            path.make(verbose=verbose)
        return dirs
        
    def update_root(cls, root: str, inplace: bool = False):
        if not inplace:
            clsdict = _EnumDict()
            clsdict._cls_name = cls.__name__
            edict = {mem.name: member(copy.deepcopy(mem.value)) for mem in cls}        
            # nenum = Enum(cls.__name__, edict)            
            for n, v in edict.items(): edict[n] = v            
            clsdict['__metaclass__'] = type(cls)
            # setattr(clsdict, '_member_names', cls._member_names_)
            nenum = type(cls.__name__, (cls, ), clsdict)
        else:
            nenum = cls
        kls = copy.deepcopy(nenum)
        kls.__members__.get('ROOT_DIR').value.update(root=root, inplace=True)
        for name, path in kls.__members__.items():
            if name == RDIR: continue
            path.value.update(root=root, inplace=True)
        return kls

# %% ../nbs/05_enum.ipynb 18
class RelDirsEnum(Enum, metaclass=RelDirsEnumMeta):
    ...
    # ROOT_DIR = ROOT_DIR
