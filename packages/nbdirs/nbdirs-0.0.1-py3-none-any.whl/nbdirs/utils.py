# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_utils.ipynb.

# %% auto 0
__all__ = ['isdunder', 'vvalue', 'newedict', 'getmembers', 'getnames', 'getmeminfo']

# %% ../nbs/03_utils.ipynb 4
import os, copy, inspect
from string import Template
from types import MethodType
from typing import Any, Dict, List, Type, Union, Optional, Iterable
from dataclasses import dataclass, field, InitVar, Field
from enum import Enum, EnumMeta, _EnumDict, member

# %% ../nbs/03_utils.ipynb 6
from .cons import (__RESTORE__, __MEMBERS__, __INHERITABLE_MEMBERS__, _MEMBER_NAMES_, VALUE, )

# %% ../nbs/03_utils.ipynb 8
def isdunder(name: str) -> bool: 
    return name.startswith('__') and name.endswith('__')

def vvalue(v: Any) -> Any:
    '''v or v.value'''
    return v.value if hasattr(v, VALUE) else v

def newedict(name) -> _EnumDict:
    '''Create a new EnumDict and set mandatory `_cls_name` attribute'''
    newdict = _EnumDict()
    newdict._cls_name = name
    return newdict

def __restore__(cls):
    setattr(cls, _MEMBER_NAMES_, list(getattr(cls, __INHERITABLE_MEMBERS__, dict()).keys()))   
    return

def getmembers(bases) -> dict:
    # arg is cls or bases
    membs = dict()
    for base in bases:        
        if not hasattr(base, __MEMBERS__): continue
        membs.update(**getattr(base, __MEMBERS__))
    return membs

def getnames(bases) -> list:
    # arg is cls or bases
    names = list()
    for base in bases:
        if not hasattr(base, _MEMBER_NAMES_): continue
        names.extend(getattr(base, _MEMBER_NAMES_, []))
    return names

def getmeminfo(bases) -> (dict, list):
    return getmembers(bases), getnames(bases)
