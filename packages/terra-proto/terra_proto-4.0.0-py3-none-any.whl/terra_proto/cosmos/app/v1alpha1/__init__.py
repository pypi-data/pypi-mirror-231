# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: cosmos/app/v1alpha1/config.proto, cosmos/app/v1alpha1/query.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class Config(betterproto.Message):
    """
    Config represents the configuration for a Cosmos SDK ABCI app. It is
    intended that all state machine logic including the version of baseapp and
    tx handlers (and possibly even Tendermint) that an app needs can be
    described in a config object. For compatibility, the framework should allow
    a mixture of declarative and imperative app wiring, however, apps that
    strive for the maximum ease of maintainability should be able to describe
    their state machine with a config object alone.
    """

    modules: List["ModuleConfig"] = betterproto.message_field(1)
    """modules are the module configurations for the app."""

    golang_bindings: List["GolangBinding"] = betterproto.message_field(2)
    """
    golang_bindings specifies explicit interface to implementation type
    bindings which depinject uses to resolve interface inputs to provider
    functions.  The scope of this field's configuration is global (not module
    specific).
    """


@dataclass(eq=False, repr=False)
class ModuleConfig(betterproto.Message):
    """ModuleConfig is a module configuration for an app."""

    name: str = betterproto.string_field(1)
    """
    name is the unique name of the module within the app. It should be a name
    that persists between different versions of a module so that modules can be
    smoothly upgraded to new versions. For example, for the module
    cosmos.bank.module.v1.Module, we may chose to simply name the module "bank"
    in the app. When we upgrade to cosmos.bank.module.v2.Module, the app-
    specific name "bank" stays the same and the framework knows that the v2
    module should receive all the same state that the v1 module had. Note:
    modules should provide info on which versions they can migrate from in the
    ModuleDescriptor.can_migration_from field.
    """

    config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(2)
    """
    config is the config object for the module. Module config messages should
    define a ModuleDescriptor using the cosmos.app.v1alpha1.is_module
    extension.
    """

    golang_bindings: List["GolangBinding"] = betterproto.message_field(3)
    """
    golang_bindings specifies explicit interface to implementation type
    bindings which depinject uses to resolve interface inputs to provider
    functions.  The scope of this field's configuration is module specific.
    """


@dataclass(eq=False, repr=False)
class GolangBinding(betterproto.Message):
    """
    GolangBinding is an explicit interface type to implementing type binding
    for dependency injection.
    """

    interface_type: str = betterproto.string_field(1)
    """
    interface_type is the interface type which will be bound to a specific
    implementation type
    """

    implementation: str = betterproto.string_field(2)
    """
    implementation is the implementing type which will be supplied when an
    input of type interface is requested
    """


@dataclass(eq=False, repr=False)
class QueryConfigRequest(betterproto.Message):
    """QueryConfigRequest is the Query/Config request type."""

    pass


@dataclass(eq=False, repr=False)
class QueryConfigResponse(betterproto.Message):
    """QueryConfigRequest is the Query/Config response type."""

    config: "Config" = betterproto.message_field(1)
    """config is the current app config."""


class QueryStub(betterproto.ServiceStub):
    async def config(
        self,
        query_config_request: "QueryConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryConfigResponse":
        return await self._unary_unary(
            "/cosmos.app.v1alpha1.Query/Config",
            query_config_request,
            QueryConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryBase(ServiceBase):
    async def config(
        self, query_config_request: "QueryConfigRequest"
    ) -> "QueryConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_config(
        self, stream: "grpclib.server.Stream[QueryConfigRequest, QueryConfigResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.config(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/cosmos.app.v1alpha1.Query/Config": grpclib.const.Handler(
                self.__rpc_config,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryConfigRequest,
                QueryConfigResponse,
            ),
        }
