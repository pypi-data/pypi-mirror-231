# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: cosmos/group/v1/query.proto, cosmos/group/v1/types.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import (
    datetime,
    timedelta,
)
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...base.query import v1beta1 as __base_query_v1_beta1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class VoteOption(betterproto.Enum):
    """VoteOption enumerates the valid vote options for a given proposal."""

    VOTE_OPTION_UNSPECIFIED = 0
    """
    VOTE_OPTION_UNSPECIFIED defines an unspecified vote option which will
    return an error.
    """

    VOTE_OPTION_YES = 1
    """VOTE_OPTION_YES defines a yes vote option."""

    VOTE_OPTION_ABSTAIN = 2
    """VOTE_OPTION_ABSTAIN defines an abstain vote option."""

    VOTE_OPTION_NO = 3
    """VOTE_OPTION_NO defines a no vote option."""

    VOTE_OPTION_NO_WITH_VETO = 4
    """VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."""


class ProposalStatus(betterproto.Enum):
    """ProposalStatus defines proposal statuses."""

    PROPOSAL_STATUS_UNSPECIFIED = 0
    """An empty value is invalid and not allowed."""

    PROPOSAL_STATUS_SUBMITTED = 1
    """Initial status of a proposal when submitted."""

    PROPOSAL_STATUS_ACCEPTED = 2
    """
    Final status of a proposal when the final tally is done and the outcome
    passes the group policy's decision policy.
    """

    PROPOSAL_STATUS_REJECTED = 3
    """
    Final status of a proposal when the final tally is done and the outcome is
    rejected by the group policy's decision policy.
    """

    PROPOSAL_STATUS_ABORTED = 4
    """
    Final status of a proposal when the group policy is modified before the
    final tally.
    """

    PROPOSAL_STATUS_WITHDRAWN = 5
    """
    A proposal can be withdrawn before the voting start time by the owner. When
    this happens the final status is Withdrawn.
    """


class ProposalExecutorResult(betterproto.Enum):
    """ProposalExecutorResult defines types of proposal executor results."""

    PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED = 0
    """An empty value is not allowed."""

    PROPOSAL_EXECUTOR_RESULT_NOT_RUN = 1
    """We have not yet run the executor."""

    PROPOSAL_EXECUTOR_RESULT_SUCCESS = 2
    """The executor was successful and proposed action updated state."""

    PROPOSAL_EXECUTOR_RESULT_FAILURE = 3
    """
    The executor returned an error and proposed action didn't update state.
    """


@dataclass(eq=False, repr=False)
class Member(betterproto.Message):
    """
    Member represents a group member with an account address, non-zero weight,
    metadata and added_at timestamp.
    """

    address: str = betterproto.string_field(1)
    """address is the member's account address."""

    weight: str = betterproto.string_field(2)
    """weight is the member's voting weight that should be greater than 0."""

    metadata: str = betterproto.string_field(3)
    """metadata is any arbitrary metadata attached to the member."""

    added_at: datetime = betterproto.message_field(4)
    """added_at is a timestamp specifying when a member was added."""


@dataclass(eq=False, repr=False)
class MemberRequest(betterproto.Message):
    """
    MemberRequest represents a group member to be used in Msg server requests.
    Contrary to `Member`, it doesn't have any `added_at` field since this field
    cannot be set as part of requests.
    """

    address: str = betterproto.string_field(1)
    """address is the member's account address."""

    weight: str = betterproto.string_field(2)
    """weight is the member's voting weight that should be greater than 0."""

    metadata: str = betterproto.string_field(3)
    """metadata is any arbitrary metadata attached to the member."""


@dataclass(eq=False, repr=False)
class ThresholdDecisionPolicy(betterproto.Message):
    """
    ThresholdDecisionPolicy is a decision policy where a proposal passes when
    it satisfies the two following conditions: 1. The sum of all `YES` voter's
    weights is greater or equal than the defined    `threshold`. 2. The voting
    and execution periods of the proposal respect the parameters    given by
    `windows`.
    """

    threshold: str = betterproto.string_field(1)
    """
    threshold is the minimum weighted sum of `YES` votes that must be met or
    exceeded for a proposal to succeed.
    """

    windows: "DecisionPolicyWindows" = betterproto.message_field(2)
    """windows defines the different windows for voting and execution."""


@dataclass(eq=False, repr=False)
class PercentageDecisionPolicy(betterproto.Message):
    """
    PercentageDecisionPolicy is a decision policy where a proposal passes when
    it satisfies the two following conditions: 1. The percentage of all `YES`
    voters' weights out of the total group weight    is greater or equal than
    the given `percentage`. 2. The voting and execution periods of the proposal
    respect the parameters    given by `windows`.
    """

    percentage: str = betterproto.string_field(1)
    """
    percentage is the minimum percentage of the weighted sum of `YES` votes
    must meet for a proposal to succeed.
    """

    windows: "DecisionPolicyWindows" = betterproto.message_field(2)
    """windows defines the different windows for voting and execution."""


@dataclass(eq=False, repr=False)
class DecisionPolicyWindows(betterproto.Message):
    """
    DecisionPolicyWindows defines the different windows for voting and
    execution.
    """

    voting_period: timedelta = betterproto.message_field(1)
    """
    voting_period is the duration from submission of a proposal to the end of
    voting period Within this times votes can be submitted with MsgVote.
    """

    min_execution_period: timedelta = betterproto.message_field(2)
    """
    min_execution_period is the minimum duration after the proposal submission
    where members can start sending MsgExec. This means that the window for
    sending a MsgExec transaction is: `[ submission + min_execution_period ;
    submission + voting_period + max_execution_period]` where
    max_execution_period is a app-specific config, defined in the keeper. If
    not set, min_execution_period will default to 0. Please make sure to set a
    `min_execution_period` that is smaller than `voting_period +
    max_execution_period`, or else the above execution window is empty, meaning
    that all proposals created with this decision policy won't be able to be
    executed.
    """


@dataclass(eq=False, repr=False)
class GroupInfo(betterproto.Message):
    """
    GroupInfo represents the high-level on-chain information for a group.
    """

    id: int = betterproto.uint64_field(1)
    """id is the unique ID of the group."""

    admin: str = betterproto.string_field(2)
    """admin is the account address of the group's admin."""

    metadata: str = betterproto.string_field(3)
    """metadata is any arbitrary metadata to attached to the group."""

    version: int = betterproto.uint64_field(4)
    """
    version is used to track changes to a group's membership structure that
    would break existing proposals. Whenever any members weight is changed, or
    any member is added or removed this version is incremented and will cause
    proposals based on older versions of this group to fail
    """

    total_weight: str = betterproto.string_field(5)
    """total_weight is the sum of the group members' weights."""

    created_at: datetime = betterproto.message_field(6)
    """created_at is a timestamp specifying when a group was created."""


@dataclass(eq=False, repr=False)
class GroupMember(betterproto.Message):
    """
    GroupMember represents the relationship between a group and a member.
    """

    group_id: int = betterproto.uint64_field(1)
    """group_id is the unique ID of the group."""

    member: "Member" = betterproto.message_field(2)
    """member is the member data."""


@dataclass(eq=False, repr=False)
class GroupPolicyInfo(betterproto.Message):
    """
    GroupPolicyInfo represents the high-level on-chain information for a group
    policy.
    """

    address: str = betterproto.string_field(1)
    """address is the account address of group policy."""

    group_id: int = betterproto.uint64_field(2)
    """group_id is the unique ID of the group."""

    admin: str = betterproto.string_field(3)
    """admin is the account address of the group admin."""

    metadata: str = betterproto.string_field(4)
    """
    metadata is any arbitrary metadata attached to the group policy. the
    recommended format of the metadata is to be found here:
    https://docs.cosmos.network/v0.47/modules/group#decision-policy-1
    """

    version: int = betterproto.uint64_field(5)
    """
    version is used to track changes to a group's GroupPolicyInfo structure
    that would create a different result on a running proposal.
    """

    decision_policy: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        6
    )
    """decision_policy specifies the group policy's decision policy."""

    created_at: datetime = betterproto.message_field(7)
    """
    created_at is a timestamp specifying when a group policy was created.
    """


@dataclass(eq=False, repr=False)
class Proposal(betterproto.Message):
    """
    Proposal defines a group proposal. Any member of a group can submit a
    proposal for a group policy to decide upon. A proposal consists of a set of
    `sdk.Msg`s that will be executed if the proposal passes as well as some
    optional metadata associated with the proposal.
    """

    id: int = betterproto.uint64_field(1)
    """id is the unique id of the proposal."""

    group_policy_address: str = betterproto.string_field(2)
    """group_policy_address is the account address of group policy."""

    metadata: str = betterproto.string_field(3)
    """
    metadata is any arbitrary metadata attached to the proposal. the
    recommended format of the metadata is to be found here:
    https://docs.cosmos.network/v0.47/modules/group#proposal-4
    """

    proposers: List[str] = betterproto.string_field(4)
    """proposers are the account addresses of the proposers."""

    submit_time: datetime = betterproto.message_field(5)
    """submit_time is a timestamp specifying when a proposal was submitted."""

    group_version: int = betterproto.uint64_field(6)
    """
    group_version tracks the version of the group at proposal submission. This
    field is here for informational purposes only.
    """

    group_policy_version: int = betterproto.uint64_field(7)
    """
    group_policy_version tracks the version of the group policy at proposal
    submission. When a decision policy is changed, existing proposals from
    previous policy versions will become invalid with the `ABORTED` status.
    This field is here for informational purposes only.
    """

    status: "ProposalStatus" = betterproto.enum_field(8)
    """
    status represents the high level position in the life cycle of the
    proposal. Initial value is Submitted.
    """

    final_tally_result: "TallyResult" = betterproto.message_field(9)
    """
    final_tally_result contains the sums of all weighted votes for this
    proposal for each vote option. It is empty at submission, and only
    populated after tallying, at voting period end or at proposal execution,
    whichever happens first.
    """

    voting_period_end: datetime = betterproto.message_field(10)
    """
    voting_period_end is the timestamp before which voting must be done. Unless
    a successful MsgExec is called before (to execute a proposal whose tally is
    successful before the voting period ends), tallying will be done at this
    point, and the `final_tally_result`and `status` fields will be accordingly
    updated.
    """

    executor_result: "ProposalExecutorResult" = betterproto.enum_field(11)
    """
    executor_result is the final result of the proposal execution. Initial
    value is NotRun.
    """

    messages: List["betterproto_lib_google_protobuf.Any"] = betterproto.message_field(
        12
    )
    """
    messages is a list of `sdk.Msg`s that will be executed if the proposal
    passes.
    """

    title: str = betterproto.string_field(13)
    """title is the title of the proposal Since: cosmos-sdk 0.47"""

    summary: str = betterproto.string_field(14)
    """summary is a short summary of the proposal Since: cosmos-sdk 0.47"""


@dataclass(eq=False, repr=False)
class TallyResult(betterproto.Message):
    """
    TallyResult represents the sum of weighted votes for each vote option.
    """

    yes_count: str = betterproto.string_field(1)
    """yes_count is the weighted sum of yes votes."""

    abstain_count: str = betterproto.string_field(2)
    """abstain_count is the weighted sum of abstainers."""

    no_count: str = betterproto.string_field(3)
    """no_count is the weighted sum of no votes."""

    no_with_veto_count: str = betterproto.string_field(4)
    """no_with_veto_count is the weighted sum of veto."""


@dataclass(eq=False, repr=False)
class Vote(betterproto.Message):
    """Vote represents a vote for a proposal."""

    proposal_id: int = betterproto.uint64_field(1)
    """proposal is the unique ID of the proposal."""

    voter: str = betterproto.string_field(2)
    """voter is the account address of the voter."""

    option: "VoteOption" = betterproto.enum_field(3)
    """option is the voter's choice on the proposal."""

    metadata: str = betterproto.string_field(4)
    """metadata is any arbitrary metadata attached to the vote."""

    submit_time: datetime = betterproto.message_field(5)
    """submit_time is the timestamp when the vote was submitted."""


@dataclass(eq=False, repr=False)
class QueryGroupInfoRequest(betterproto.Message):
    """QueryGroupInfoRequest is the Query/GroupInfo request type."""

    group_id: int = betterproto.uint64_field(1)
    """group_id is the unique ID of the group."""


@dataclass(eq=False, repr=False)
class QueryGroupInfoResponse(betterproto.Message):
    """QueryGroupInfoResponse is the Query/GroupInfo response type."""

    info: "GroupInfo" = betterproto.message_field(1)
    """info is the GroupInfo of the group."""


@dataclass(eq=False, repr=False)
class QueryGroupPolicyInfoRequest(betterproto.Message):
    """
    QueryGroupPolicyInfoRequest is the Query/GroupPolicyInfo request type.
    """

    address: str = betterproto.string_field(1)
    """address is the account address of the group policy."""


@dataclass(eq=False, repr=False)
class QueryGroupPolicyInfoResponse(betterproto.Message):
    """
    QueryGroupPolicyInfoResponse is the Query/GroupPolicyInfo response type.
    """

    info: "GroupPolicyInfo" = betterproto.message_field(1)
    """info is the GroupPolicyInfo of the group policy."""


@dataclass(eq=False, repr=False)
class QueryGroupMembersRequest(betterproto.Message):
    """QueryGroupMembersRequest is the Query/GroupMembers request type."""

    group_id: int = betterproto.uint64_field(1)
    """group_id is the unique ID of the group."""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryGroupMembersResponse(betterproto.Message):
    """
    QueryGroupMembersResponse is the Query/GroupMembersResponse response type.
    """

    members: List["GroupMember"] = betterproto.message_field(1)
    """members are the members of the group with given group_id."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryGroupsByAdminRequest(betterproto.Message):
    """QueryGroupsByAdminRequest is the Query/GroupsByAdmin request type."""

    admin: str = betterproto.string_field(1)
    """admin is the account address of a group's admin."""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryGroupsByAdminResponse(betterproto.Message):
    """
    QueryGroupsByAdminResponse is the Query/GroupsByAdminResponse response
    type.
    """

    groups: List["GroupInfo"] = betterproto.message_field(1)
    """groups are the groups info with the provided admin."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryGroupPoliciesByGroupRequest(betterproto.Message):
    """
    QueryGroupPoliciesByGroupRequest is the Query/GroupPoliciesByGroup request
    type.
    """

    group_id: int = betterproto.uint64_field(1)
    """group_id is the unique ID of the group policy's group."""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryGroupPoliciesByGroupResponse(betterproto.Message):
    """
    QueryGroupPoliciesByGroupResponse is the Query/GroupPoliciesByGroup
    response type.
    """

    group_policies: List["GroupPolicyInfo"] = betterproto.message_field(1)
    """
    group_policies are the group policies info associated with the provided
    group.
    """

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryGroupPoliciesByAdminRequest(betterproto.Message):
    """
    QueryGroupPoliciesByAdminRequest is the Query/GroupPoliciesByAdmin request
    type.
    """

    admin: str = betterproto.string_field(1)
    """admin is the admin address of the group policy."""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryGroupPoliciesByAdminResponse(betterproto.Message):
    """
    QueryGroupPoliciesByAdminResponse is the Query/GroupPoliciesByAdmin
    response type.
    """

    group_policies: List["GroupPolicyInfo"] = betterproto.message_field(1)
    """group_policies are the group policies info with provided admin."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryProposalRequest(betterproto.Message):
    """QueryProposalRequest is the Query/Proposal request type."""

    proposal_id: int = betterproto.uint64_field(1)
    """proposal_id is the unique ID of a proposal."""


@dataclass(eq=False, repr=False)
class QueryProposalResponse(betterproto.Message):
    """QueryProposalResponse is the Query/Proposal response type."""

    proposal: "Proposal" = betterproto.message_field(1)
    """proposal is the proposal info."""


@dataclass(eq=False, repr=False)
class QueryProposalsByGroupPolicyRequest(betterproto.Message):
    """
    QueryProposalsByGroupPolicyRequest is the Query/ProposalByGroupPolicy
    request type.
    """

    address: str = betterproto.string_field(1)
    """
    address is the account address of the group policy related to proposals.
    """

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryProposalsByGroupPolicyResponse(betterproto.Message):
    """
    QueryProposalsByGroupPolicyResponse is the Query/ProposalByGroupPolicy
    response type.
    """

    proposals: List["Proposal"] = betterproto.message_field(1)
    """proposals are the proposals with given group policy."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryVoteByProposalVoterRequest(betterproto.Message):
    """
    QueryVoteByProposalVoterRequest is the Query/VoteByProposalVoter request
    type.
    """

    proposal_id: int = betterproto.uint64_field(1)
    """proposal_id is the unique ID of a proposal."""

    voter: str = betterproto.string_field(2)
    """voter is a proposal voter account address."""


@dataclass(eq=False, repr=False)
class QueryVoteByProposalVoterResponse(betterproto.Message):
    """
    QueryVoteByProposalVoterResponse is the Query/VoteByProposalVoter response
    type.
    """

    vote: "Vote" = betterproto.message_field(1)
    """vote is the vote with given proposal_id and voter."""


@dataclass(eq=False, repr=False)
class QueryVotesByProposalRequest(betterproto.Message):
    """
    QueryVotesByProposalRequest is the Query/VotesByProposal request type.
    """

    proposal_id: int = betterproto.uint64_field(1)
    """proposal_id is the unique ID of a proposal."""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryVotesByProposalResponse(betterproto.Message):
    """
    QueryVotesByProposalResponse is the Query/VotesByProposal response type.
    """

    votes: List["Vote"] = betterproto.message_field(1)
    """votes are the list of votes for given proposal_id."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryVotesByVoterRequest(betterproto.Message):
    """QueryVotesByVoterRequest is the Query/VotesByVoter request type."""

    voter: str = betterproto.string_field(1)
    """voter is a proposal voter account address."""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryVotesByVoterResponse(betterproto.Message):
    """QueryVotesByVoterResponse is the Query/VotesByVoter response type."""

    votes: List["Vote"] = betterproto.message_field(1)
    """votes are the list of votes by given voter."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryGroupsByMemberRequest(betterproto.Message):
    """QueryGroupsByMemberRequest is the Query/GroupsByMember request type."""

    address: str = betterproto.string_field(1)
    """address is the group member address."""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryGroupsByMemberResponse(betterproto.Message):
    """
    QueryGroupsByMemberResponse is the Query/GroupsByMember response type.
    """

    groups: List["GroupInfo"] = betterproto.message_field(1)
    """groups are the groups info with the provided group member."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryTallyResultRequest(betterproto.Message):
    """QueryTallyResultRequest is the Query/TallyResult request type."""

    proposal_id: int = betterproto.uint64_field(1)
    """proposal_id is the unique id of a proposal."""


@dataclass(eq=False, repr=False)
class QueryTallyResultResponse(betterproto.Message):
    """QueryTallyResultResponse is the Query/TallyResult response type."""

    tally: "TallyResult" = betterproto.message_field(1)
    """tally defines the requested tally."""


@dataclass(eq=False, repr=False)
class QueryGroupsRequest(betterproto.Message):
    """
    QueryGroupsRequest is the Query/Groups request type. Since: cosmos-sdk
    0.47.1
    """

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryGroupsResponse(betterproto.Message):
    """
    QueryGroupsResponse is the Query/Groups response type. Since: cosmos-sdk
    0.47.1
    """

    groups: List["GroupInfo"] = betterproto.message_field(1)
    """`groups` is all the groups present in state."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


class QueryStub(betterproto.ServiceStub):
    async def group_info(
        self,
        query_group_info_request: "QueryGroupInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupInfoResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupInfo",
            query_group_info_request,
            QueryGroupInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def group_policy_info(
        self,
        query_group_policy_info_request: "QueryGroupPolicyInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupPolicyInfoResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupPolicyInfo",
            query_group_policy_info_request,
            QueryGroupPolicyInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def group_members(
        self,
        query_group_members_request: "QueryGroupMembersRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupMembersResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupMembers",
            query_group_members_request,
            QueryGroupMembersResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def groups_by_admin(
        self,
        query_groups_by_admin_request: "QueryGroupsByAdminRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupsByAdminResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupsByAdmin",
            query_groups_by_admin_request,
            QueryGroupsByAdminResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def group_policies_by_group(
        self,
        query_group_policies_by_group_request: "QueryGroupPoliciesByGroupRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupPoliciesByGroupResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupPoliciesByGroup",
            query_group_policies_by_group_request,
            QueryGroupPoliciesByGroupResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def group_policies_by_admin(
        self,
        query_group_policies_by_admin_request: "QueryGroupPoliciesByAdminRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupPoliciesByAdminResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupPoliciesByAdmin",
            query_group_policies_by_admin_request,
            QueryGroupPoliciesByAdminResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def proposal(
        self,
        query_proposal_request: "QueryProposalRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryProposalResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/Proposal",
            query_proposal_request,
            QueryProposalResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def proposals_by_group_policy(
        self,
        query_proposals_by_group_policy_request: "QueryProposalsByGroupPolicyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryProposalsByGroupPolicyResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/ProposalsByGroupPolicy",
            query_proposals_by_group_policy_request,
            QueryProposalsByGroupPolicyResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def vote_by_proposal_voter(
        self,
        query_vote_by_proposal_voter_request: "QueryVoteByProposalVoterRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryVoteByProposalVoterResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/VoteByProposalVoter",
            query_vote_by_proposal_voter_request,
            QueryVoteByProposalVoterResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def votes_by_proposal(
        self,
        query_votes_by_proposal_request: "QueryVotesByProposalRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryVotesByProposalResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/VotesByProposal",
            query_votes_by_proposal_request,
            QueryVotesByProposalResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def votes_by_voter(
        self,
        query_votes_by_voter_request: "QueryVotesByVoterRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryVotesByVoterResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/VotesByVoter",
            query_votes_by_voter_request,
            QueryVotesByVoterResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def groups_by_member(
        self,
        query_groups_by_member_request: "QueryGroupsByMemberRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupsByMemberResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupsByMember",
            query_groups_by_member_request,
            QueryGroupsByMemberResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def tally_result(
        self,
        query_tally_result_request: "QueryTallyResultRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryTallyResultResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/TallyResult",
            query_tally_result_request,
            QueryTallyResultResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def groups(
        self,
        query_groups_request: "QueryGroupsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupsResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/Groups",
            query_groups_request,
            QueryGroupsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryBase(ServiceBase):
    async def group_info(
        self, query_group_info_request: "QueryGroupInfoRequest"
    ) -> "QueryGroupInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def group_policy_info(
        self, query_group_policy_info_request: "QueryGroupPolicyInfoRequest"
    ) -> "QueryGroupPolicyInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def group_members(
        self, query_group_members_request: "QueryGroupMembersRequest"
    ) -> "QueryGroupMembersResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def groups_by_admin(
        self, query_groups_by_admin_request: "QueryGroupsByAdminRequest"
    ) -> "QueryGroupsByAdminResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def group_policies_by_group(
        self, query_group_policies_by_group_request: "QueryGroupPoliciesByGroupRequest"
    ) -> "QueryGroupPoliciesByGroupResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def group_policies_by_admin(
        self, query_group_policies_by_admin_request: "QueryGroupPoliciesByAdminRequest"
    ) -> "QueryGroupPoliciesByAdminResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def proposal(
        self, query_proposal_request: "QueryProposalRequest"
    ) -> "QueryProposalResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def proposals_by_group_policy(
        self,
        query_proposals_by_group_policy_request: "QueryProposalsByGroupPolicyRequest",
    ) -> "QueryProposalsByGroupPolicyResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def vote_by_proposal_voter(
        self, query_vote_by_proposal_voter_request: "QueryVoteByProposalVoterRequest"
    ) -> "QueryVoteByProposalVoterResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def votes_by_proposal(
        self, query_votes_by_proposal_request: "QueryVotesByProposalRequest"
    ) -> "QueryVotesByProposalResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def votes_by_voter(
        self, query_votes_by_voter_request: "QueryVotesByVoterRequest"
    ) -> "QueryVotesByVoterResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def groups_by_member(
        self, query_groups_by_member_request: "QueryGroupsByMemberRequest"
    ) -> "QueryGroupsByMemberResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def tally_result(
        self, query_tally_result_request: "QueryTallyResultRequest"
    ) -> "QueryTallyResultResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def groups(
        self, query_groups_request: "QueryGroupsRequest"
    ) -> "QueryGroupsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_group_info(
        self,
        stream: "grpclib.server.Stream[QueryGroupInfoRequest, QueryGroupInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.group_info(request)
        await stream.send_message(response)

    async def __rpc_group_policy_info(
        self,
        stream: "grpclib.server.Stream[QueryGroupPolicyInfoRequest, QueryGroupPolicyInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.group_policy_info(request)
        await stream.send_message(response)

    async def __rpc_group_members(
        self,
        stream: "grpclib.server.Stream[QueryGroupMembersRequest, QueryGroupMembersResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.group_members(request)
        await stream.send_message(response)

    async def __rpc_groups_by_admin(
        self,
        stream: "grpclib.server.Stream[QueryGroupsByAdminRequest, QueryGroupsByAdminResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.groups_by_admin(request)
        await stream.send_message(response)

    async def __rpc_group_policies_by_group(
        self,
        stream: "grpclib.server.Stream[QueryGroupPoliciesByGroupRequest, QueryGroupPoliciesByGroupResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.group_policies_by_group(request)
        await stream.send_message(response)

    async def __rpc_group_policies_by_admin(
        self,
        stream: "grpclib.server.Stream[QueryGroupPoliciesByAdminRequest, QueryGroupPoliciesByAdminResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.group_policies_by_admin(request)
        await stream.send_message(response)

    async def __rpc_proposal(
        self,
        stream: "grpclib.server.Stream[QueryProposalRequest, QueryProposalResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.proposal(request)
        await stream.send_message(response)

    async def __rpc_proposals_by_group_policy(
        self,
        stream: "grpclib.server.Stream[QueryProposalsByGroupPolicyRequest, QueryProposalsByGroupPolicyResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.proposals_by_group_policy(request)
        await stream.send_message(response)

    async def __rpc_vote_by_proposal_voter(
        self,
        stream: "grpclib.server.Stream[QueryVoteByProposalVoterRequest, QueryVoteByProposalVoterResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.vote_by_proposal_voter(request)
        await stream.send_message(response)

    async def __rpc_votes_by_proposal(
        self,
        stream: "grpclib.server.Stream[QueryVotesByProposalRequest, QueryVotesByProposalResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.votes_by_proposal(request)
        await stream.send_message(response)

    async def __rpc_votes_by_voter(
        self,
        stream: "grpclib.server.Stream[QueryVotesByVoterRequest, QueryVotesByVoterResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.votes_by_voter(request)
        await stream.send_message(response)

    async def __rpc_groups_by_member(
        self,
        stream: "grpclib.server.Stream[QueryGroupsByMemberRequest, QueryGroupsByMemberResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.groups_by_member(request)
        await stream.send_message(response)

    async def __rpc_tally_result(
        self,
        stream: "grpclib.server.Stream[QueryTallyResultRequest, QueryTallyResultResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.tally_result(request)
        await stream.send_message(response)

    async def __rpc_groups(
        self, stream: "grpclib.server.Stream[QueryGroupsRequest, QueryGroupsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.groups(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/cosmos.group.v1.Query/GroupInfo": grpclib.const.Handler(
                self.__rpc_group_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupInfoRequest,
                QueryGroupInfoResponse,
            ),
            "/cosmos.group.v1.Query/GroupPolicyInfo": grpclib.const.Handler(
                self.__rpc_group_policy_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupPolicyInfoRequest,
                QueryGroupPolicyInfoResponse,
            ),
            "/cosmos.group.v1.Query/GroupMembers": grpclib.const.Handler(
                self.__rpc_group_members,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupMembersRequest,
                QueryGroupMembersResponse,
            ),
            "/cosmos.group.v1.Query/GroupsByAdmin": grpclib.const.Handler(
                self.__rpc_groups_by_admin,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupsByAdminRequest,
                QueryGroupsByAdminResponse,
            ),
            "/cosmos.group.v1.Query/GroupPoliciesByGroup": grpclib.const.Handler(
                self.__rpc_group_policies_by_group,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupPoliciesByGroupRequest,
                QueryGroupPoliciesByGroupResponse,
            ),
            "/cosmos.group.v1.Query/GroupPoliciesByAdmin": grpclib.const.Handler(
                self.__rpc_group_policies_by_admin,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupPoliciesByAdminRequest,
                QueryGroupPoliciesByAdminResponse,
            ),
            "/cosmos.group.v1.Query/Proposal": grpclib.const.Handler(
                self.__rpc_proposal,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryProposalRequest,
                QueryProposalResponse,
            ),
            "/cosmos.group.v1.Query/ProposalsByGroupPolicy": grpclib.const.Handler(
                self.__rpc_proposals_by_group_policy,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryProposalsByGroupPolicyRequest,
                QueryProposalsByGroupPolicyResponse,
            ),
            "/cosmos.group.v1.Query/VoteByProposalVoter": grpclib.const.Handler(
                self.__rpc_vote_by_proposal_voter,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryVoteByProposalVoterRequest,
                QueryVoteByProposalVoterResponse,
            ),
            "/cosmos.group.v1.Query/VotesByProposal": grpclib.const.Handler(
                self.__rpc_votes_by_proposal,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryVotesByProposalRequest,
                QueryVotesByProposalResponse,
            ),
            "/cosmos.group.v1.Query/VotesByVoter": grpclib.const.Handler(
                self.__rpc_votes_by_voter,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryVotesByVoterRequest,
                QueryVotesByVoterResponse,
            ),
            "/cosmos.group.v1.Query/GroupsByMember": grpclib.const.Handler(
                self.__rpc_groups_by_member,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupsByMemberRequest,
                QueryGroupsByMemberResponse,
            ),
            "/cosmos.group.v1.Query/TallyResult": grpclib.const.Handler(
                self.__rpc_tally_result,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTallyResultRequest,
                QueryTallyResultResponse,
            ),
            "/cosmos.group.v1.Query/Groups": grpclib.const.Handler(
                self.__rpc_groups,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupsRequest,
                QueryGroupsResponse,
            ),
        }
