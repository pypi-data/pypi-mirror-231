# coding: utf-8


"""
IGNORE:
    Nutanix Prism Versioned APIs

    Task Management, Category Associations, Prism Central DR, Alerts, Alert policies, Events and Audits  # noqa: E501

    OpenAPI spec version: 4.0.3-alpha-2
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
IGNORE
"""
import pprint
import json
import ast
import re  # noqa: F401

import six
from ntnx_prism_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
from ntnx_prism_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
from ntnx_prism_py_client.models.prism.v4.config.AssociationDetail import AssociationDetail  # noqa: F401,E501
from ntnx_prism_py_client.models.prism.v4.config.AssociationSummary import AssociationSummary  # noqa: F401,E501
from ntnx_prism_py_client.models.prism.v4.config.CategoryType import CategoryType  # noqa: F401,E501

class Category(ExternalizableAbstractModel):

    """

    :param key: (:attr:`key`) key when represented as `key:value` pair.  Constraints:  * A string of maxlength of 64 * Character at the start cannot be `$` * Character `/` is not allowed anywhere  It is a mandatory input field in the payload during category creation. This field stays immutable post creation of the category. 
    :type key: required
    :param value: (:attr:`value`) value when represented as a `key:value` pair.  Constraints:  * A string of maxlength 64 * Character at the start cannot be `$` * Character `/` is not allowed anywhere  It is a mandatory input field in the payload during category creation. This field can be updated. 
    :type value: required
    :param type: (:attr:`type`) 
    :type type: 
    :param description: (:attr:`description`) A string consisting of the description of the category as defined by the user. The server does not validate this value nor does it enforce the uniqueness or any other constraints. It is the responsibility of the user to ensure that any semantic or syntactic constraints are retained when mutating this field. 
    :type description: 
    :param owner_uuid: (:attr:`owner_uuid`) This field denotes the owner of this category. It contains the UUID reference of a user who can sign in to Nutanix systems. The logged-in user who created the category becomes the owner of the category. This field can be edited only by a super-admin/legacy/local type of user. This field cannot be deleted, indicating that a category will always have an owner. It is used for enabling authorization of a particular kind where the user has no access to view/create/update/delete any categories other than the categories created by that user. 
    :type owner_uuid: 
    :param associations: (:attr:`associations`) DecRef(associationsFieldDesc)
    :type associations: 
    :param detailed_associations: (:attr:`detailed_associations`) This is the array field contains associations details. Each association entry has resourceGroup like (ENTITY or POLICY), resourceType(like VM, HOST belonging to ENTITY resourceGroup and NGT_POLICY, PROTECTION_POLICY belonging to POLICY resourceGroup), count (number of entities/policies associated with this category) and resourceIdList (list of entities/policies UUIDs associated with this category). $expand=detailedAssociations query parameter is supported only for the Get Category By Id API call and it is not supported for List Categories API call.
    :type detailed_associations: 

    """
    """
    IGNORE:
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    IGNORE
    """  # noqa: E501
    swagger_types = {
        'key': 'str',
        'value': 'str',
        'type': 'prism.v4.config.CategoryType',
        'description': 'str',
        'owner_uuid': 'str',
        'associations': 'list[prism.v4.config.AssociationSummary]',
        'detailed_associations': 'list[prism.v4.config.AssociationDetail]',
        'ext_id': 'str',
        'links': 'list[common.v1.response.ApiLink]',
        'tenant_id': 'str',
        '_reserved': 'dict(str, object)',
        '_object_type': 'str',
        '_unknown_fields': 'dict(str, object)',
    }

    attribute_map = {
        'key': 'key',
        'value': 'value',
        'type': 'type',
        'description': 'description',
        'owner_uuid': 'ownerUuid',
        'associations': 'associations',
        'detailed_associations': 'detailedAssociations',
        'ext_id': 'extId',
        'links': 'links',
        'tenant_id': 'tenantId',
        '_reserved': '$reserved',
        '_object_type': '$objectType',
        '_unknown_fields': '$unknownFields',
    }



    def __init__(self, key=None, value=None, type=None, description=None, owner_uuid=None, associations=None, detailed_associations=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
        self.__key = None
        self.__value = None
        self.__type = None
        self.__description = None
        self.__owner_uuid = None
        self.__associations = None
        self.__detailed_associations = None
        self.discriminator = None
        self.__key = key
        self.__value = value
        if type is not None:
            self.__type = type
        if description is not None:
            self.__description = description
        if owner_uuid is not None:
            self.__owner_uuid = owner_uuid
        if associations is not None:
            self.__associations = associations
        if detailed_associations is not None:
            self.__detailed_associations = detailed_associations

    def _initialize_object_type(self):
        return 'prism.v4.config.Category'

    def _initialize_fq_object_type(self):
        return 'prism.v4.r0.a2.config.Category'


    @property
    def key(self):
        """
        key when represented as `key:value` pair.  Constraints:  * A string of maxlength of 64 * Character at the start cannot be `$` * Character `/` is not allowed anywhere  It is a mandatory input field in the payload during category creation. This field stays immutable post creation of the category. 

        :type:

                :class:`~str`
        """  # noqa: E501
        return self.__key

    @key.setter
    def key(self, key):
        if key is None:
            raise ValueError("Invalid value for `key`, must not be `None`")  # noqa: E501
        if key is not None and len(key) > 64:
            raise ValueError("Invalid value for `key`, length must be less than or equal to `64`")  # noqa: E501
        if key is not None and not re.search('^[^$\/][^\/]{0,63}$', key):  # noqa: E501
            raise ValueError(r"Invalid value for `key`, must be a follow pattern or equal to `/^[^$\/][^\/]{0,63}$/`")  # noqa: E501

        self.__key = key

    @property
    def value(self):
        """
        value when represented as a `key:value` pair.  Constraints:  * A string of maxlength 64 * Character at the start cannot be `$` * Character `/` is not allowed anywhere  It is a mandatory input field in the payload during category creation. This field can be updated. 

        :type:

                :class:`~str`
        """  # noqa: E501
        return self.__value

    @value.setter
    def value(self, value):
        if value is None:
            raise ValueError("Invalid value for `value`, must not be `None`")  # noqa: E501
        if value is not None and len(value) > 64:
            raise ValueError("Invalid value for `value`, length must be less than or equal to `64`")  # noqa: E501
        if value is not None and not re.search('^[^$\/][^\/]{0,63}$', value):  # noqa: E501
            raise ValueError(r"Invalid value for `value`, must be a follow pattern or equal to `/^[^$\/][^\/]{0,63}$/`")  # noqa: E501

        self.__value = value

    @property
    def type(self):
        """
        

        :type:
            :class:`~ntnx_prism_py_client.models.prism.v4.config.CategoryType`
        """  # noqa: E501
        return self.__type

    @type.setter
    def type(self, type):

        self.__type = type

    @property
    def description(self):
        """
        A string consisting of the description of the category as defined by the user. The server does not validate this value nor does it enforce the uniqueness or any other constraints. It is the responsibility of the user to ensure that any semantic or syntactic constraints are retained when mutating this field. 

        :type:

                :class:`~str`
        """  # noqa: E501
        return self.__description

    @description.setter
    def description(self, description):
        if description is not None and not re.search('^.{0,512}$', description):  # noqa: E501
            raise ValueError(r"Invalid value for `description`, must be a follow pattern or equal to `/^.{0,512}$/`")  # noqa: E501

        self.__description = description

    @property
    def owner_uuid(self):
        """
        This field denotes the owner of this category. It contains the UUID reference of a user who can sign in to Nutanix systems. The logged-in user who created the category becomes the owner of the category. This field can be edited only by a super-admin/legacy/local type of user. This field cannot be deleted, indicating that a category will always have an owner. It is used for enabling authorization of a particular kind where the user has no access to view/create/update/delete any categories other than the categories created by that user. 

        :type:

                :class:`~str`
        """  # noqa: E501
        return self.__owner_uuid

    @owner_uuid.setter
    def owner_uuid(self, owner_uuid):
        if owner_uuid is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', owner_uuid):  # noqa: E501
            raise ValueError(r"Invalid value for `owner_uuid`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501

        self.__owner_uuid = owner_uuid

    @property
    def associations(self):
        """
        DecRef(associationsFieldDesc)

        :type:
             list[ :class:`~ntnx_prism_py_client.models.prism.v4.config.AssociationSummary` ]
        """  # noqa: E501
        return self.__associations

    @associations.setter
    def associations(self, associations):

        self.__associations = associations

    @property
    def detailed_associations(self):
        """
        This is the array field contains associations details. Each association entry has resourceGroup like (ENTITY or POLICY), resourceType(like VM, HOST belonging to ENTITY resourceGroup and NGT_POLICY, PROTECTION_POLICY belonging to POLICY resourceGroup), count (number of entities/policies associated with this category) and resourceIdList (list of entities/policies UUIDs associated with this category). $expand=detailedAssociations query parameter is supported only for the Get Category By Id API call and it is not supported for List Categories API call.

        :type:
             list[ :class:`~ntnx_prism_py_client.models.prism.v4.config.AssociationDetail` ]
        """  # noqa: E501
        return self.__detailed_associations

    @detailed_associations.setter
    def detailed_associations(self, detailed_associations):

        self.__detailed_associations = detailed_associations

    def _to_dict(self, sanitize):
        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.

        :param sanitize: A flag to omit None properties if set to True
        :type sanitize: bool
        """

        result = {}

        for attr, attr_type in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                    value
                ))
            elif hasattr(value, "_to_dict"):
                result[attr] = value._to_dict(sanitize)
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1]._to_dict(sanitize))
                    if hasattr(item[1], "_to_dict") else item,
                    six.iteritems(value)
                ))
            else:
                if sanitize:
                    if value is not None:
                        result[attr] = value
                else:
                    result[attr] = value
        if issubclass(Category, dict):
            for key, value in six.iteritems(self):
                result[key] = value

        return result

    def to_dict(self):
        """Returns the model properties as a dictionary"""
        return self._to_dict(False)

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self._to_dict(True))

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Category):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other

