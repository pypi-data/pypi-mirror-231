{"version":3,"file":"jupyter-lsp-connection.455853ae52cee6d27066.js?v=455853ae52cee6d27066","mappings":"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","sources":["webpack://@jupyter-lsp/jupyterlab-lsp/./src/connection.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../lsp-ws-connection/src/server-capability-registration.ts"],"sourcesContent":["// Disclaimer/acknowledgement: Fragments are based on LspWsConnection, which is copyright of wylieconlon and contributors and ISC licenced.\n// ISC licence is, quote, \"functionally equivalent to the simplified BSD and MIT licenses,\n// but without language deemed unnecessary following the Berne Convention.\" (Wikipedia).\n// Introduced modifications are BSD licenced, copyright JupyterLab development team.\nimport { ISignal, Signal } from '@lumino/signaling';\nimport {\n  AnyCompletion,\n  AnyLocation,\n  IDocumentInfo,\n  ILspOptions,\n  IPosition,\n  LspWsConnection\n} from 'lsp-ws-connection';\nimport {\n  registerServerCapability,\n  unregisterServerCapability\n} from 'lsp-ws-connection/lib/server-capability-registration';\nimport type * as rpc from 'vscode-jsonrpc';\nimport type * as lsp from 'vscode-languageserver-protocol';\nimport type { MessageConnection } from 'vscode-ws-jsonrpc';\n\nimport { ClientCapabilities } from './lsp';\nimport { ILSPLogConsole } from './tokens';\nimport { until_ready } from './utils';\n\ninterface ILSPOptions extends ILspOptions {\n  capabilities: ClientCapabilities;\n  serverIdentifier?: string;\n  console: ILSPLogConsole;\n}\n\n/**\n * Method strings are reproduced here because a non-typing import of\n * `vscode-languageserver-protocol` is ridiculously expensive.\n */\nexport namespace Method {\n  /** Server notifications */\n  export enum ServerNotification {\n    PUBLISH_DIAGNOSTICS = 'textDocument/publishDiagnostics',\n    SHOW_MESSAGE = 'window/showMessage',\n    LOG_TRACE = '$/logTrace',\n    LOG_MESSAGE = 'window/logMessage'\n  }\n\n  /** Client notifications */\n  export enum ClientNotification {\n    DID_CHANGE = 'textDocument/didChange',\n    DID_CHANGE_CONFIGURATION = 'workspace/didChangeConfiguration',\n    DID_OPEN = 'textDocument/didOpen',\n    DID_SAVE = 'textDocument/didSave',\n    INITIALIZED = 'initialized',\n    SET_TRACE = '$/setTrace'\n  }\n\n  /** Server requests */\n  export enum ServerRequest {\n    REGISTER_CAPABILITY = 'client/registerCapability',\n    SHOW_MESSAGE_REQUEST = 'window/showMessageRequest',\n    UNREGISTER_CAPABILITY = 'client/unregisterCapability',\n    WORKSPACE_CONFIGURATION = 'workspace/configuration'\n  }\n\n  /** Client requests */\n  export enum ClientRequest {\n    COMPLETION = 'textDocument/completion',\n    COMPLETION_ITEM_RESOLVE = 'completionItem/resolve',\n    DEFINITION = 'textDocument/definition',\n    DOCUMENT_HIGHLIGHT = 'textDocument/documentHighlight',\n    DOCUMENT_SYMBOL = 'textDocument/documentSymbol',\n    HOVER = 'textDocument/hover',\n    IMPLEMENTATION = 'textDocument/implementation',\n    INITIALIZE = 'initialize',\n    REFERENCES = 'textDocument/references',\n    RENAME = 'textDocument/rename',\n    SIGNATURE_HELP = 'textDocument/signatureHelp',\n    TYPE_DEFINITION = 'textDocument/typeDefinition'\n  }\n}\n\nexport interface IServerNotifyParams {\n  [Method.ServerNotification.LOG_MESSAGE]: lsp.LogMessageParams;\n  [Method.ServerNotification.LOG_TRACE]: rpc.LogTraceParams;\n  [Method.ServerNotification.PUBLISH_DIAGNOSTICS]: lsp.PublishDiagnosticsParams;\n  [Method.ServerNotification.SHOW_MESSAGE]: lsp.ShowMessageParams;\n}\n\nexport interface IClientNotifyParams {\n  [Method.ClientNotification\n    .DID_CHANGE_CONFIGURATION]: lsp.DidChangeConfigurationParams;\n  [Method.ClientNotification.DID_CHANGE]: lsp.DidChangeTextDocumentParams;\n  [Method.ClientNotification.DID_OPEN]: lsp.DidOpenTextDocumentParams;\n  [Method.ClientNotification.DID_SAVE]: lsp.DidSaveTextDocumentParams;\n  [Method.ClientNotification.INITIALIZED]: lsp.InitializedParams;\n  [Method.ClientNotification.SET_TRACE]: rpc.SetTraceParams;\n}\n\nexport interface IServerRequestParams {\n  [Method.ServerRequest.REGISTER_CAPABILITY]: lsp.RegistrationParams;\n  [Method.ServerRequest.SHOW_MESSAGE_REQUEST]: lsp.ShowMessageRequestParams;\n  [Method.ServerRequest.UNREGISTER_CAPABILITY]: lsp.UnregistrationParams;\n  [Method.ServerRequest.WORKSPACE_CONFIGURATION]: lsp.ConfigurationParams;\n}\n\nexport interface IServerResult {\n  [Method.ServerRequest.REGISTER_CAPABILITY]: void;\n  [Method.ServerRequest.SHOW_MESSAGE_REQUEST]: lsp.MessageActionItem | null;\n  [Method.ServerRequest.UNREGISTER_CAPABILITY]: void;\n  [Method.ServerRequest.WORKSPACE_CONFIGURATION]: any[];\n}\n\nexport interface IClientRequestParams {\n  [Method.ClientRequest.COMPLETION_ITEM_RESOLVE]: lsp.CompletionItem;\n  [Method.ClientRequest.COMPLETION]: lsp.CompletionParams;\n  [Method.ClientRequest.DEFINITION]: lsp.TextDocumentPositionParams;\n  [Method.ClientRequest.DOCUMENT_HIGHLIGHT]: lsp.TextDocumentPositionParams;\n  [Method.ClientRequest.DOCUMENT_SYMBOL]: lsp.DocumentSymbolParams;\n  [Method.ClientRequest.HOVER]: lsp.TextDocumentPositionParams;\n  [Method.ClientRequest.IMPLEMENTATION]: lsp.TextDocumentPositionParams;\n  [Method.ClientRequest.INITIALIZE]: lsp.InitializeParams;\n  [Method.ClientRequest.REFERENCES]: lsp.ReferenceParams;\n  [Method.ClientRequest.RENAME]: lsp.RenameParams;\n  [Method.ClientRequest.SIGNATURE_HELP]: lsp.TextDocumentPositionParams;\n  [Method.ClientRequest.TYPE_DEFINITION]: lsp.TextDocumentPositionParams;\n}\n\nexport interface IClientResult {\n  [Method.ClientRequest.COMPLETION_ITEM_RESOLVE]: lsp.CompletionItem;\n  [Method.ClientRequest.COMPLETION]: AnyCompletion;\n  [Method.ClientRequest.DEFINITION]: AnyLocation;\n  [Method.ClientRequest.DOCUMENT_HIGHLIGHT]: lsp.DocumentHighlight[];\n  [Method.ClientRequest.DOCUMENT_SYMBOL]: lsp.DocumentSymbol[];\n  [Method.ClientRequest.HOVER]: lsp.Hover | null;\n  [Method.ClientRequest.IMPLEMENTATION]: AnyLocation;\n  [Method.ClientRequest.INITIALIZE]: lsp.InitializeResult;\n  [Method.ClientRequest.REFERENCES]: lsp.Location[] | null;\n  [Method.ClientRequest.RENAME]: lsp.WorkspaceEdit;\n  [Method.ClientRequest.SIGNATURE_HELP]: lsp.SignatureHelp;\n  [Method.ClientRequest.TYPE_DEFINITION]: AnyLocation;\n}\n\nexport type ServerNotifications<\n  T extends keyof IServerNotifyParams = keyof IServerNotifyParams\n> = {\n  readonly // ISignal does not have emit, which is intended - client cannot emit server notifications.\n  [key in T]: ISignal<LSPConnection, IServerNotifyParams[key]>;\n};\n\nexport type ClientNotifications<\n  T extends keyof IClientNotifyParams = keyof IClientNotifyParams\n> = {\n  readonly // Signal has emit.\n  [key in T]: Signal<LSPConnection, IClientNotifyParams[key]>;\n};\n\nexport interface IClientRequestHandler<\n  T extends keyof IClientRequestParams = keyof IClientRequestParams\n> {\n  request(params: IClientRequestParams[T]): Promise<IClientResult[T]>;\n}\n\nexport interface IServerRequestHandler<\n  T extends keyof IServerRequestParams = keyof IServerRequestParams\n> {\n  setHandler(\n    handler: (\n      params: IServerRequestParams[T],\n      connection?: LSPConnection\n    ) => Promise<IServerResult[T]>\n  ): void;\n  clearHandler(): void;\n}\n\nexport type ClientRequests<\n  T extends keyof IClientRequestParams = keyof IClientRequestParams\n> = {\n  readonly // has async request(params) returning a promise with result.\n  [key in T]: IClientRequestHandler<key>;\n};\n\nexport type ServerRequests<\n  T extends keyof IServerRequestParams = keyof IServerRequestParams\n> = {\n  readonly // has async request(params) returning a promise with result.\n  [key in T]: IServerRequestHandler<key>;\n};\n\nclass ClientRequestHandler<\n  T extends keyof IClientRequestParams = keyof IClientRequestParams\n> implements IClientRequestHandler\n{\n  constructor(\n    protected connection: MessageConnection,\n    protected method: T,\n    protected emitter: LSPConnection\n  ) {}\n  request(params: IClientRequestParams[T]): Promise<IClientResult[T]> {\n    // TODO check if is ready?\n    this.emitter.log(MessageKind.client_requested, {\n      method: this.method,\n      message: params\n    });\n    return this.connection\n      .sendRequest(this.method, params)\n      .then((result: IClientResult[T]) => {\n        this.emitter.log(MessageKind.result_for_client, {\n          method: this.method,\n          message: params\n        });\n        return result;\n      });\n  }\n}\n\nclass ServerRequestHandler<\n  T extends keyof IServerRequestParams = keyof IServerRequestParams\n> implements IServerRequestHandler\n{\n  private _handler:\n    | ((\n        params: IServerRequestParams[T],\n        connection?: LSPConnection\n      ) => Promise<IServerResult[T]>)\n    | null;\n\n  constructor(\n    protected connection: MessageConnection,\n    protected method: T,\n    protected emitter: LSPConnection\n  ) {\n    // on request accepts \"thenable\"\n    this.connection.onRequest(method, this.handle.bind(this));\n    this._handler = null;\n  }\n\n  private handle(\n    request: IServerRequestParams[T]\n  ): Promise<IServerResult[T] | undefined> {\n    this.emitter.log(MessageKind.server_requested, {\n      method: this.method,\n      message: request\n    });\n    if (!this._handler) {\n      return new Promise(() => undefined);\n    }\n    return this._handler(request, this.emitter).then(result => {\n      this.emitter.log(MessageKind.response_for_server, {\n        method: this.method,\n        message: result\n      });\n      return result;\n    });\n  }\n\n  setHandler(\n    handler: (\n      params: IServerRequestParams[T],\n      connection?: LSPConnection\n    ) => Promise<IServerResult[T]>\n  ) {\n    this._handler = handler;\n  }\n\n  clearHandler() {\n    this._handler = null;\n  }\n}\n\nexport const Provider: { [key: string]: keyof lsp.ServerCapabilities } = {\n  TEXT_DOCUMENT_SYNC: 'textDocumentSync',\n  COMPLETION: 'completionProvider',\n  HOVER: 'hoverProvider',\n  SIGNATURE_HELP: 'signatureHelpProvider',\n  DECLARATION: 'declarationProvider',\n  DEFINITION: 'definitionProvider',\n  TYPE_DEFINITION: 'typeDefinitionProvider',\n  IMPLEMENTATION: 'implementationProvider',\n  REFERENCES: 'referencesProvider',\n  DOCUMENT_HIGHLIGHT: 'documentHighlightProvider',\n  DOCUMENT_SYMBOL: 'documentSymbolProvider',\n  CODE_ACTION: 'codeActionProvider',\n  CODE_LENS: 'codeLensProvider',\n  DOCUMENT_LINK: 'documentLinkProvider',\n  COLOR: 'colorProvider',\n  DOCUMENT_FORMATTING: 'documentFormattingProvider',\n  DOCUMENT_RANGE_FORMATTING: 'documentRangeFormattingProvider',\n  DOCUMENT_ON_TYPE_FORMATTING: 'documentOnTypeFormattingProvider',\n  RENAME: 'renameProvider',\n  FOLDING_RANGE: 'foldingRangeProvider',\n  EXECUTE_COMMAND: 'executeCommandProvider',\n  SELECTION_RANGE: 'selectionRangeProvider',\n  WORKSPACE_SYMBOL: 'workspaceSymbolProvider',\n  WORKSPACE: 'workspace'\n};\n\ntype AnyMethodType =\n  | typeof Method.ServerNotification\n  | typeof Method.ClientNotification\n  | typeof Method.ClientRequest\n  | typeof Method.ServerRequest;\ntype AnyMethod =\n  | Method.ServerNotification\n  | Method.ClientNotification\n  | Method.ClientRequest\n  | Method.ServerRequest;\n\nfunction createMethodMap<T, H, U extends keyof T = keyof T>(\n  methods: AnyMethodType,\n  handlerFactory: (method: U) => H\n) {\n  const result: { [key in U]?: H } = {};\n  for (let method of Object.values(methods)) {\n    result[method as U] = handlerFactory(method as U);\n  }\n  return result as T;\n}\n\nenum MessageKind {\n  client_notified_server,\n  server_notified_client,\n  server_requested,\n  client_requested,\n  result_for_client,\n  response_for_server\n}\n\ninterface IMessageLog<T extends AnyMethod = AnyMethod> {\n  method: T;\n  message: any;\n}\n\nexport class LSPConnection extends LspWsConnection {\n  protected documentsToOpen: IDocumentInfo[];\n  public serverIdentifier?: string;\n\n  public clientNotifications: ClientNotifications;\n  public serverNotifications: ServerNotifications;\n  public clientRequests: ClientRequests;\n  public serverRequests: ServerRequests;\n  protected console: ILSPLogConsole;\n  private _options: ILSPOptions;\n  public logAllCommunication: boolean;\n\n  public log(kind: MessageKind, message: IMessageLog) {\n    if (this.logAllCommunication) {\n      this.console.log(kind, message);\n    }\n  }\n\n  protected constructNotificationHandlers<\n    T extends ServerNotifications | ClientNotifications\n  >(\n    methods: typeof Method.ServerNotification | typeof Method.ClientNotification\n  ) {\n    return createMethodMap<T, Signal<any, any>>(\n      methods,\n      () => new Signal<any, any>(this)\n    );\n  }\n\n  protected constructClientRequestHandler<\n    T extends ClientRequests,\n    U extends keyof T = keyof T\n  >(methods: typeof Method.ClientRequest) {\n    return createMethodMap<T, IClientRequestHandler>(\n      methods,\n      method =>\n        new ClientRequestHandler(this.connection, method as U as any, this)\n    );\n  }\n\n  protected constructServerRequestHandler<\n    T extends ServerRequests,\n    U extends keyof T = keyof T\n  >(methods: typeof Method.ServerRequest) {\n    return createMethodMap<T, IServerRequestHandler>(\n      methods,\n      method =>\n        new ServerRequestHandler(this.connection, method as U as any, this)\n    );\n  }\n\n  constructor(options: ILSPOptions) {\n    super(options);\n    this._options = options;\n    this.logAllCommunication = false;\n    this.serverIdentifier = options.serverIdentifier;\n    this.console = options.console.scope(this.serverIdentifier + ' connection');\n    this.documentsToOpen = [];\n    this.clientNotifications =\n      this.constructNotificationHandlers<ClientNotifications>(\n        Method.ClientNotification\n      );\n    this.serverNotifications =\n      this.constructNotificationHandlers<ServerNotifications>(\n        Method.ServerNotification\n      );\n  }\n\n  /**\n   * Initialization parameters to be sent to the language server.\n   * Subclasses can overload this when adding more features.\n   */\n  protected initializeParams(): lsp.InitializeParams {\n    return {\n      ...super.initializeParams(),\n      // TODO: remove as `lsp.ClientCapabilities` after upgrading to 3.17\n      // which should finally include a fix for moniker issue:\n      // https://github.com/microsoft/vscode-languageserver-node/pull/720\n      capabilities: this._options.capabilities as lsp.ClientCapabilities,\n      initializationOptions: null,\n      processId: null,\n      workspaceFolders: null\n    };\n  }\n\n  sendOpenWhenReady(documentInfo: IDocumentInfo) {\n    if (this.isReady) {\n      this.sendOpen(documentInfo);\n    } else {\n      this.documentsToOpen.push(documentInfo);\n    }\n  }\n\n  protected onServerInitialized(params: lsp.InitializeResult) {\n    this.afterInitialized();\n    super.onServerInitialized(params);\n    while (this.documentsToOpen.length) {\n      this.sendOpen(this.documentsToOpen.pop()!);\n    }\n  }\n\n  protected afterInitialized() {\n    for (const method of Object.values(\n      Method.ServerNotification\n    ) as (keyof ServerNotifications)[]) {\n      const signal = this.serverNotifications[method] as Signal<any, any>;\n      this.connection.onNotification(method, params => {\n        this.log(MessageKind.server_notified_client, {\n          method,\n          message: params\n        });\n        signal.emit(params);\n      });\n    }\n\n    for (const method of Object.values(\n      Method.ClientNotification\n    ) as (keyof ClientNotifications)[]) {\n      const signal = this.clientNotifications[method] as Signal<any, any>;\n      signal.connect((emitter, params) => {\n        this.log(MessageKind.client_notified_server, {\n          method,\n          message: params\n        });\n        void this.connection.sendNotification(method, params);\n      });\n    }\n\n    this.clientRequests = this.constructClientRequestHandler<ClientRequests>(\n      Method.ClientRequest\n    );\n    this.serverRequests = this.constructServerRequestHandler<ServerRequests>(\n      Method.ServerRequest\n    );\n\n    this.serverRequests['client/registerCapability'].setHandler(\n      async (params: lsp.RegistrationParams) => {\n        params.registrations.forEach(\n          (capabilityRegistration: lsp.Registration) => {\n            try {\n              const updatedCapabilities = registerServerCapability(\n                this.serverCapabilities,\n                capabilityRegistration\n              );\n              if (updatedCapabilities === null) {\n                this.console.error(\n                  `Failed to register server capability: ${capabilityRegistration}`\n                );\n                return;\n              }\n              this.serverCapabilities = updatedCapabilities;\n            } catch (err) {\n              this.console.error(err);\n            }\n          }\n        );\n      }\n    );\n\n    this.serverRequests['client/unregisterCapability'].setHandler(\n      async (params: lsp.UnregistrationParams) => {\n        params.unregisterations.forEach(\n          (capabilityUnregistration: lsp.Unregistration) => {\n            this.serverCapabilities = unregisterServerCapability(\n              this.serverCapabilities,\n              capabilityUnregistration\n            );\n          }\n        );\n      }\n    );\n\n    this.serverRequests['workspace/configuration'].setHandler(async params => {\n      return params.items.map(item => {\n        // LSP: \"If the client can’t provide a configuration setting for a given scope\n        // then `null` needs to be present in the returned array.\"\n\n        // for now we do not support configuration, but yaml server does not respect\n        // client capability so we have a handler just for that\n        return null;\n      });\n    });\n  }\n\n  public sendSelectiveChange(\n    changeEvent: lsp.TextDocumentContentChangeEvent,\n    documentInfo: IDocumentInfo\n  ) {\n    this._sendChange([changeEvent], documentInfo);\n  }\n\n  public sendFullTextChange(text: string, documentInfo: IDocumentInfo): void {\n    this._sendChange([{ text }], documentInfo);\n  }\n\n  /**\n   * @deprecated The method should not be used in new code. Use provides() instead.\n   */\n  public isRenameSupported() {\n    return !!(\n      this.serverCapabilities && this.serverCapabilities.renameProvider\n    );\n  }\n\n  provides(provider: keyof lsp.ServerCapabilities): boolean {\n    return !!(this.serverCapabilities && this.serverCapabilities[provider]);\n  }\n\n  /**\n   * @deprecated The method should not be used in new code\n   */\n  async rename(\n    location: IPosition,\n    documentInfo: IDocumentInfo,\n    newName: string,\n    emit = true\n  ): Promise<lsp.WorkspaceEdit | null> {\n    if (!this.isReady || !this.isRenameSupported()) {\n      return null;\n    }\n\n    const params: lsp.RenameParams = {\n      textDocument: {\n        uri: documentInfo.uri\n      },\n      position: {\n        line: location.line,\n        character: location.ch\n      },\n      newName\n    };\n\n    const edit: lsp.WorkspaceEdit = await this.connection.sendRequest(\n      'textDocument/rename',\n      params\n    );\n\n    if (emit) {\n      this.emit('renamed', edit);\n    }\n\n    return edit;\n  }\n\n  public connect(socket: WebSocket): this {\n    super.connect(socket);\n\n    until_ready(() => {\n      return this.isConnected;\n    }, -1)\n      .then(() => {\n        this.connection.onClose(() => {\n          this.isConnected = false;\n          this.emit('close', this.closing_manually);\n        });\n      })\n      .catch(() => {\n        console.error('Could not connect onClose signal');\n      });\n    return this;\n  }\n\n  private closing_manually = false;\n\n  public close() {\n    try {\n      this.closing_manually = true;\n      super.close();\n    } catch (e) {\n      this.closing_manually = false;\n    }\n  }\n\n  private _sendChange(\n    changeEvents: lsp.TextDocumentContentChangeEvent[],\n    documentInfo: IDocumentInfo\n  ) {\n    if (!this.isReady) {\n      return;\n    }\n    if (!this.openedUris.get(documentInfo.uri)) {\n      this.sendOpen(documentInfo);\n    }\n    const textDocumentChange: lsp.DidChangeTextDocumentParams = {\n      textDocument: {\n        uri: documentInfo.uri,\n        version: documentInfo.version\n      } as lsp.VersionedTextDocumentIdentifier,\n      contentChanges: changeEvents\n    };\n    void this.connection.sendNotification(\n      'textDocument/didChange',\n      textDocumentChange\n    );\n    documentInfo.version++;\n  }\n\n  async getCompletionResolve(completionItem: lsp.CompletionItem) {\n    if (!this.isReady || !this.isCompletionResolveProvider()) {\n      return;\n    }\n    return this.connection.sendRequest<lsp.CompletionItem>(\n      'completionItem/resolve',\n      completionItem\n    );\n  }\n\n  /**\n   * Does support completionItem/resolve?\n   * @deprecated The method should not be used in new code\n   */\n  public isCompletionResolveProvider(): boolean {\n    return (\n      this.serverCapabilities?.completionProvider?.resolveProvider || false\n    );\n  }\n}\n","import {\n  Registration,\n  ServerCapabilities,\n  Unregistration\n} from 'vscode-languageserver-protocol';\n\ninterface IFlexibleServerCapabilities extends ServerCapabilities {\n  [key: string]: any;\n}\n\nfunction registerServerCapability(\n  serverCapabilities: ServerCapabilities,\n  registration: Registration\n): ServerCapabilities | null {\n  const serverCapabilitiesCopy = JSON.parse(\n    JSON.stringify(serverCapabilities)\n  ) as IFlexibleServerCapabilities;\n  const { method, registerOptions } = registration;\n  const providerName = method.substring(13) + 'Provider';\n\n  if (providerName) {\n    if (!registerOptions) {\n      serverCapabilitiesCopy[providerName] = true;\n    } else {\n      serverCapabilitiesCopy[providerName] = JSON.parse(\n        JSON.stringify(registerOptions)\n      );\n    }\n  } else {\n    console.warn('Could not register server capability.', registration);\n    return null;\n  }\n\n  return serverCapabilitiesCopy;\n}\n\nfunction unregisterServerCapability(\n  serverCapabilities: ServerCapabilities,\n  unregistration: Unregistration\n): ServerCapabilities {\n  const serverCapabilitiesCopy = JSON.parse(\n    JSON.stringify(serverCapabilities)\n  ) as IFlexibleServerCapabilities;\n  const { method } = unregistration;\n  const providerName = method.substring(13) + 'Provider';\n\n  delete serverCapabilitiesCopy[providerName];\n\n  return serverCapabilitiesCopy;\n}\n\nexport { registerServerCapability, unregisterServerCapability };\n"],"names":["Method","ServerNotification","ClientNotification","ServerRequest","ClientRequest","ClientRequestHandler","constructor","connection","method","emitter","request","params","this","log","MessageKind","client_requested","message","sendRequest","then","result","result_for_client","ServerRequestHandler","onRequest","handle","bind","_handler","server_requested","response_for_server","Promise","setHandler","handler","clearHandler","Provider","TEXT_DOCUMENT_SYNC","COMPLETION","HOVER","SIGNATURE_HELP","DECLARATION","DEFINITION","TYPE_DEFINITION","IMPLEMENTATION","REFERENCES","DOCUMENT_HIGHLIGHT","DOCUMENT_SYMBOL","CODE_ACTION","CODE_LENS","DOCUMENT_LINK","COLOR","DOCUMENT_FORMATTING","DOCUMENT_RANGE_FORMATTING","DOCUMENT_ON_TYPE_FORMATTING","RENAME","FOLDING_RANGE","EXECUTE_COMMAND","SELECTION_RANGE","WORKSPACE_SYMBOL","WORKSPACE","createMethodMap","methods","handlerFactory","Object","values","LSPConnection","LspWsConnection","kind","logAllCommunication","console","constructNotificationHandlers","Signal","constructClientRequestHandler","constructServerRequestHandler","options","super","closing_manually","_options","serverIdentifier","scope","documentsToOpen","clientNotifications","serverNotifications","initializeParams","capabilities","initializationOptions","processId","workspaceFolders","sendOpenWhenReady","documentInfo","isReady","sendOpen","push","onServerInitialized","afterInitialized","length","pop","signal","onNotification","server_notified_client","emit","connect","client_notified_server","sendNotification","clientRequests","serverRequests","async","registrations","forEach","capabilityRegistration","updatedCapabilities","serverCapabilities","registration","serverCapabilitiesCopy","JSON","parse","stringify","registerOptions","providerName","substring","warn","error","err","unregisterations","capabilityUnregistration","unregistration","items","map","item","sendSelectiveChange","changeEvent","_sendChange","sendFullTextChange","text","isRenameSupported","renameProvider","provides","provider","location","newName","textDocument","uri","position","line","character","ch","edit","socket","isConnected","onClose","catch","close","e","changeEvents","openedUris","get","textDocumentChange","version","contentChanges","completionItem","isCompletionResolveProvider","completionProvider","resolveProvider"],"sourceRoot":""}