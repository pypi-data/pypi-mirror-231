# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: blickfeld/percept_processing/data/data_type.proto, blickfeld/percept_processing/data/health.proto, blickfeld/percept_processing/data/state.proto, blickfeld/percept_processing/data/state_list.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import List

import blickfeld_qb2.betterproto as betterproto
import blickfeld_qb2.betterproto.lib.google.protobuf as betterproto_lib_google_protobuf

from ...base import (
    data as __base_data__,
    geometry as __base_geometry__,
)
from ...percept_pipeline import data as __percept_pipeline_data__


class DataType(betterproto.Enum):
    """The type of data that the stream contains"""

    DATA_TYPE_UNSPECIFIED = 0
    """The zero value should not be used"""

    DATA_TYPE_HEALTH = 1
    """
    Health data type: this contains information about the health of the
    pipeline and of the module
    """

    DATA_TYPE_POINT_CLOUD = 2
    """Point cloud data type: a complete point cloud message is streamed"""

    DATA_TYPE_STATE_LIST = 4
    """
    State list data type: a list of states generated by the zones configured in
    the pipeline
    """


@dataclass(eq=False, repr=False)
class State(betterproto.Message):
    """
    A state transmits high-level information about the scene or setup. The
    information it contains depends on the configuration. States will get
    calculated on every frame of measurement.
    """

    timestamp: datetime = betterproto.message_field(1)
    """Timestamp of the lidar frame in which the state was measured"""

    generator_uuid: str = betterproto.string_field(2)
    """The uuid of the entity generating this state"""

    generator_name: str = betterproto.string_field(8)
    """The name of the entity generating this state"""

    security: "StateSecurity" = betterproto.message_field(5, group="state_type")
    """The security state contains intrusion information of a zone"""

    volume: "StateVolume" = betterproto.message_field(7, group="state_type")
    """Current volume measured in the selected zone"""


@dataclass(eq=False, repr=False)
class StateSecurity(betterproto.Message):
    """A message containing an alarm state of a zone."""

    alarm: bool = betterproto.bool_field(1)
    """If there is an alarm or not in the zone"""

    num_detected_points: int = betterproto.uint32_field(2)
    """The current number of lidar points detected in the zone"""


@dataclass(eq=False, repr=False)
class StateVolume(betterproto.Message):
    """
    A message containing the volume state of a zone. This is based on one
    volume zone.
    """

    volume: float = betterproto.float_field(1)
    """
    The indices of Volume Tiles are expressed w.r.t the Volume Map  coordinate
    system. The tile with index (0,0) will contain the points  from [0,
    tile_size), [0, tile_size). That means that (0,0,0) of the  Volume Map
    frame does not coincide with the center of the tile with  index (0,0) but
    with the crossing of the 4 tiles [(0,0), (0, -1,),  (-1,-1), (-1,0)].
    Additionally the volume tile could have multiple vertical clusters that
    will represent the data inside the tile. The current volume of the zone
    """

    tiles: List["StateVolumeVolumeTile"] = betterproto.message_field(2)
    """
    The tiles of the volume map The volume of a zone is approximated by a
    'volume map' see xref:blickfeld/percept_pipeline/config/zone_algorithm.adoc
    #_blickfeld_percept_pipeline_config_ZoneAlgorithm_Volume[Volume] for more
    details. NOTE: For performance reasons this field is currently not filled.
    """

    tile_size: float = betterproto.float_field(3)
    """The tile size of the volume map"""

    shape: "__base_geometry__.Shape" = betterproto.message_field(4)
    """
    The shape of the volume map, defining the pose and the dimension of the
    volume map in world frame. The shape is similar to the shape of the input
    zone with the following difference: - shape.pose.position:
    (x=zone.pose.position.x, y=zone.pose.position.y, z=0) -
    shape.pose.rotation: (roll=0, pitch=0, yaw=zone.pose.rotation.yaw) -
    shape.box.dimension: (x=zone.box.dimension.x, y=zone.box.dimension.y, z=0)
    """


@dataclass(eq=False, repr=False)
class StateVolumeVolumeTile(betterproto.Message):
    """Message of a single volume tile"""

    index_x: int = betterproto.int32_field(1)
    """Grid Map Tile Index X (can be negative and positive)"""

    index_y: int = betterproto.int32_field(2)
    """Grid Map Tile Index Y (can be negative and positive)"""

    heights: List[float] = betterproto.float_field(3)
    """Height per cluster, ordered ascending"""

    std_deviations: List[float] = betterproto.float_field(4)
    """Standard Deviation per cluster"""

    number_points: List[float] = betterproto.float_field(5)
    """Points per cluster"""


@dataclass(eq=False, repr=False)
class StateList(betterproto.Message):
    """
    A message that contains a list of states. A state is an information
    generated by the system based on the select zone type or device. For
    example, a state can contain information about the volume or the intrusion
    in the zone.
    """

    timestamp: datetime = betterproto.message_field(1)
    """The timestamp of the message construction."""

    states: List["State"] = betterproto.message_field(2)
    """List of states."""


@dataclass(eq=False, repr=False)
class Health(betterproto.Message):
    """
    A health message that contains information about the pipeline status and
    the module itself.
    """

    state: "__base_data__.HealthState" = betterproto.enum_field(1)
    """High-level state of module."""

    state_reason: str = betterproto.string_field(2)
    """Reason for the given state. It is not set if state is STATE_OK."""

    pipeline_state: "__percept_pipeline_data__.State" = betterproto.enum_field(4)
    """
    Current state of the pipeline. It indicates if the pipeline is stable,
    unstable or broken, based on the frequency of the data that is processed
    and published.
    """
